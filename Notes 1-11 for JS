Chapter 1 Introduction

JavaScript is a versatile programming language originally created to make web pages interactive. Scripts written in JavaScript can be embedded in HTML and run automatically as the page loads, without requiring compilation.

Key Features of JavaScript
Origins and Name: Initially called LiveScript, it was renamed to JavaScript to leverage Java's popularity. Over time, it became independent and follows the ECMAScript specification.
Execution Environments: While primarily browser-based, JavaScript can now run on servers and other devices with JavaScript engines (e.g., V8 in Chrome, SpiderMonkey in Firefox).
Engine Workflow: Engines parse scripts, compile them into machine code, and optimize the code for fast execution.
Capabilities of In-Browser JavaScript
What It Can Do:
Manipulate HTML and CSS.
Respond to user actions (e.g., clicks, key presses).
Send/receive network requests.
Store data locally on the client side.
What It Cannot Do:
Access files or OS-level functions without user permission.
Interact with other browser tabs (due to the Same Origin Policy).
Communicate freely with external domains without explicit consent (via CORS).
What Makes JavaScript Unique
JavaScript stands out for its:

Seamless integration with HTML/CSS.
Simplicity for basic tasks.
Ubiquitous support across all major browsers.
It is the most popular tool for creating browser interfaces and has extended uses, such as building servers and mobile apps.

Languages That Compile to JavaScript
To address varying needs, developers have created languages that transpile to JavaScript, such as:

CoffeeScript: Adds concise syntax.
TypeScript: Introduces strict typing for complex systems.
Flow: Adds data typing differently.
Dart: A standalone language also transpilable to JavaScript.
Brython: Enables Python to work as JavaScript.
Kotlin: Targets both browsers and Node.js.
Summary
JavaScript began as a browser-exclusive language but is now used in many environments. It remains the most widely adopted language for browser development, fully integrated with HTML/CSS, and serves as the foundation for many modern programming languages.


Code Editors: The Programmer's Workspace
Programmers spend most of their time using code editors, which come in two main types: IDEs (Integrated Development Environments) and lightweight editors. Many developers use one of each based on their needs.

Integrated Development Environments (IDEs)
An IDE is a feature-rich editor designed to handle entire projects. It provides:

Project-level tools: Handles multiple files and navigation.
Autocompletion: Based on the entire project, not just the open file.
Integration: With version control (e.g., Git), testing environments, and other tools.
Popular IDEs:
Visual Studio Code: Cross-platform and free.
WebStorm: Cross-platform and paid.
Visual Studio (Windows only): A paid, powerful IDE for .NET and JavaScript, with a free version called Visual Studio Community.


Chapter 2 Java Fundamentals

Statements
Definition: Syntax constructs and commands that perform actions.
Examples:
javascript
Copy code
alert('Hello'); 
alert('World');
Separation: Statements are typically separated by semicolons (;) for clarity.
Semicolons
Optional in Some Cases:

JavaScript often uses automatic semicolon insertion (ASI) when there’s a line break.
javascript
Copy code
alert('Hello')
alert('World')
This works due to implicit semicolon insertion.

Exceptions to ASI:

Newlines don’t always imply semicolons. For example:
javascript
Copy code
alert(3 +
1
+ 2);
Outputs 6, as JavaScript understands the expression continues.
Potential Errors:

Missing semicolons can lead to hard-to-detect errors, such as:
javascript
Copy code
alert("Hello")
[1, 2].forEach(alert); // Treated as a single invalid statement.
To avoid such issues, always use semicolons between statements.
Comments
Comments help explain code and are ignored by the JavaScript engine.

Single-Line Comments: Use //.

javascript
Copy code
// This is a single-line comment
alert('Hello'); // Comment after a statement
Multi-Line Comments: Use /* */.

javascript
Copy code
/* This is a 
   multi-line comment */
alert('Hello');
Disabling Code: Comments can temporarily disable code.

javascript
Copy code
/* alert('Hello'); */
alert('World');
Nested Comments: Not supported. Nested /*...*/ will cause errors.

javascript
Copy code
/*
  /* Invalid nested comment */
*/
Hotkeys for Commenting: Most editors allow commenting with shortcuts:

Single-line: Ctrl+/ or Cmd+/ (Mac).
Multi-line: Ctrl+Shift+/ or Cmd+Option+/ (Mac).

What is "use strict"?
Definition: A special directive to enable modern JavaScript functionality.
Purpose:
Fixes past mistakes in JavaScript.
Enforces stricter parsing and error handling for better code quality.
How to Enable Strict Mode?
For the Whole Script: Place "use strict" at the top of your script.

javascript
Copy code
"use strict";

// Modern strict mode is enabled
let x = 3.14; // Allowed in strict mode
For Specific Functions: Place "use strict" inside a function to enable strict mode only within that function.

javascript
Copy code
function example() {
  "use strict";
  // Strict mode is active here
}

// Outside the function, no strict mode
Rules for Placement
"use strict" must be at the very top of the script or function.
No code (except comments) should appear before it:
javascript
Copy code
alert("some code"); // Incorrect: "use strict" ignored
"use strict";       // Ignored here
Key Notes About "use strict"
Irreversible:

Once enabled, strict mode cannot be turned off within the same script.
Browser Console Behavior:

The browser console doesn’t use strict mode by default.
To enable it:
javascript
Copy code
'use strict'; 
// Your code here
Workaround for Older Consoles:

javascript
Copy code
(function() {
  'use strict';

  // Your code here
})();
Do We Need "use strict"?
For Now:

Add "use strict" at the top of your scripts to enable modern behavior.
In the Future:

Once you use advanced features like classes and modules, "use strict" becomes unnecessary as they enable strict mode automatically.
Benefits of Strict Mode
Eliminates some silent JavaScript errors by changing them to throw errors.
Prevents the use of certain bad practices.
Makes debugging easier by providing clearer error messages.
Ensures better compatibility with future JavaScript versions.
Summary
Start scripts with "use strict" to write cleaner and safer code.
Transition to using classes and modules in modern projects to benefit from automatic strict mode.
All examples in this tutorial assume strict mode unless stated otherwise.

String quotes
importance: 5
What is the output of the script?

Number: Regular numbers (e.g., 123), special values like Infinity and NaN.
BigInt: For very large integers.
String: Text inside quotes ("Hello").
Boolean: True or false.
Null: Represents "nothing."
Undefined: Variable declared but not assigned a value.
Symbol: Unique identifiers.
Object: Complex data like arrays or functions.
The typeof operator tells the type of a value but has quirks (e.g., typeof null is "object", which is incorrect).

let name = "Ilya";

alert( hello ${1} ); // ?

alert( hello ${"name"} ); // ?

alert( hello ${name} ); // ?

alert( \hello ${1}` );`

${1} is a simple expression containing the number 1.
The result is hello 1.
alert( \hello ${"name"}` );`

${"name"} is a string literal "name". It does not refer to the variable name, as it’s enclosed in quotes.
The result is hello name.
alert( \hello ${name}` );`

${name} refers to the variable name, which has the value "Ilya".
The result is hello Ilya.

hello 1
hello name
hello Ilya

Operands & Operators: An operand is what operators act on (e.g., in 5 + 3, 5 and 3 are operands, + is the operator).

Unary operators work on one operand (e.g., -x).
Binary operators work on two operands (e.g., x - y).
Math Operators: JavaScript supports:

Addition +, Subtraction -, Multiplication *, Division /, Remainder %, and Exponentiation **.
Remainder (%) gives the remainder of division.
Exponentiation ()** raises a number to a power (e.g., 2 ** 3 = 8).
String Concatenation: The + operator can also join strings (e.g., 'Hello' + ' ' + 'World' gives 'Hello World').

Unary Plus (+): Converts a value to a number (e.g., +"3" turns into 3).

Operator Precedence: Operators have a priority in which they are evaluated. For example, multiplication * happens before addition +.

Assignment (=): Stores values in variables. It has low precedence and can be used in expressions, such as x = y = 3.

Increment/Decrement: ++ increases by 1, -- decreases by 1. They can be used in prefix or postfix form (++x or x++).

Modify-in-place: Shortened operators like +=, -= help modify a variable directly (e.g., x += 5 is the same as x = x + 5).

Bitwise Operators: These work with binary representations of numbers and are rarely used in regular web development.

Comma Operator (,): Allows multiple expressions to be evaluated in one line, but only the result of the last one is returned.

These operators are fundamental in JavaScript, and understanding their behavior helps in writing clear and efficient code.

Summary of JavaScript Comparison Operators:
Comparison Operators:

> (greater than), < (less than), >= (greater than or equal), <= (less than or equal), == (equal), != (not equal).
== checks equality but converts types, while === checks strict equality without type conversion.
Boolean Result: Comparison operators return either true or false.

String Comparison:

Strings are compared letter-by-letter using Unicode order (case matters). For example, 'Z' > 'A' is true because 'Z' comes after 'A' in Unicode.
Comparing Different Types:

JavaScript converts different types to numbers when comparing. For instance, '2' > 1 is true because '2' is converted to the number 2.
Boolean Comparisons:

true becomes 1 and false becomes 0 during comparisons. For example, true == 1 is true.
Strict Equality:

== may return unexpected results (e.g., 0 == false is true), while === avoids these issues by not converting types (e.g., 0 === false is false).
Null and Undefined Comparisons:

null and undefined are only equal to each other with ==, not with other values. They behave differently in comparisons:
null == undefined is true
null > 0 is false but null >= 0 is true.
undefined is special and shouldn't be compared to other values, as comparisons like undefined > 0 will return false.
Avoiding Pitfalls:

Be cautious when comparing null or undefined, especially with operators like >=, >, <, and <=. It's a good practice to check for null/undefined separately.

Summary of Conditional Branching in JavaScript
The if Statement:

It evaluates a condition, and if the condition is true, it executes the block of code inside the if block.
Example:
javascript
Copy code
let year = prompt('In which year was ECMAScript-2015 specification published?', '');
if (year == 2015) alert('You are right!');
Curly Braces:

Always use curly braces {} around the code block even for single statements to improve readability.
Boolean Conversion:

JavaScript treats certain values as falsy (e.g., 0, "", null, undefined, NaN) and others as truthy (e.g., any non-zero number, non-empty string).
Example:
javascript
Copy code
if (1) { ... } // Always executes
if (0) { ... } // Never executes
else Clause:

The else block executes when the condition in the if statement is falsy.
Example:
javascript
Copy code
if (year == 2015) {
  alert('Correct!');
} else {
  alert('Incorrect!');
}
Multiple Conditions (else if):

You can check multiple conditions using else if.
Example:
javascript
Copy code
if (year < 2015) {
  alert('Too early!');
} else if (year > 2015) {
  alert('Too late!');
} else {
  alert('Exactly!');
}
The Conditional (?) Operator:

It’s a shorthand for if-else and evaluates a condition to return one of two values based on the condition’s truthiness.
Syntax:
javascript
Copy code
let result = condition ? value1 : value2;
Example:
javascript
Copy code
let accessAllowed = (age > 18) ? true : false;
Multiple ? (Ternary Chain):

You can chain multiple ? operators to test several conditions in a sequence.
Example:
javascript
Copy code
let message = (age < 3) ? 'Hi, baby!' : 
  (age < 18) ? 'Hello!' : 
  (age < 100) ? 'Greetings!' : 
  'What an unusual age!';
Non-traditional Use of ?:

You can use ? to execute different code based on a condition without assigning the result to a variable. However, it’s not recommended for readability.
Example:
javascript
Copy code
(company == 'Netscape') ? alert('Right!') : alert('Wrong.');
Best Practices:
Use if-else when you need to perform different actions.
Use ? when you need to return one of two values based on a condition.
Avoid using ? for executing multiple statements or when readability might suffer.

Summary of Logical Operators in JavaScript
|| (OR Operator):

Basic Use: The OR operator returns true if at least one of the operands is truthy; otherwise, it returns false.

Example:
javascript
Copy code
alert(true || false);  // true
alert(false || false); // false
Truthy and Falsy Values: In JavaScript, the OR operator evaluates operands and returns the first truthy value or the last operand if none are truthy.

Example:
javascript
Copy code
alert(1 || 0); // 1 (truthy)
alert(null || 0 || 1); // 1 (first truthy value)
alert(undefined || null || 0); // 0 (all falsy, returns last value)
Short-Circuit Evaluation: OR stops evaluating once it finds a truthy value.

Example:
javascript
Copy code
true || alert("not printed");
false || alert("printed");  // "printed"
&& (AND Operator):

Basic Use: The AND operator returns true if both operands are truthy, otherwise it returns false.

Example:
javascript
Copy code
alert(true && true); // true
alert(true && false); // false
Truthy and Falsy Values: In JavaScript, AND returns the first falsy value or the last operand if all are truthy.

Example:
javascript
Copy code
alert(1 && 0); // 0 (first falsy value)
alert(1 && 5); // 5 (both truthy)
alert(null && 5); // null (first falsy value)
Short-Circuit Evaluation: AND stops evaluating once it finds a falsy value.

Example:
javascript
Copy code
null && alert("printed"); // does not execute alert
! (NOT Operator):

Basic Use: The NOT operator negates a boolean value, converting it to its opposite (true becomes false, and false becomes true).

Example:
javascript
Copy code
alert(!true); // false
alert(!0);    // true
Double NOT (!!): A common technique to convert any value to its boolean equivalent.

Example:
javascript
Copy code
alert(!!"non-empty string"); // true
alert(!!null);               // false
Operator Precedence:

The NOT (!) operator has the highest precedence, followed by AND (&&), and then OR (||).
Example:
javascript
Copy code
alert(true && false || true);  // true (AND has higher precedence than OR)
Best Practices and Usage Recommendations:
Use || when you need to evaluate whether at least one condition is true.
Use && when you need to ensure that all conditions are true.
Use ! for negating a boolean value, or to convert a value to its boolean equivalent using !!.
Avoid replacing if with &&: While && can execute a statement conditionally, if statements are generally more readable for branching logic. Use && for checking conditions but stick to if for more complex logic.

Types of Loops:
while loop:

Repeats the code while the condition is truthy.
The condition is checked before each iteration.
Example:
javascript
Copy code
let i = 0;
while (i < 3) {
  alert(i);
  i++;
}
do...while loop:

Executes the code at least once, and then checks the condition.
The condition is checked after each iteration.
Example:
javascript
Copy code
let i = 0;
do {
  alert(i);
  i++;
} while (i < 3);
for loop:

A more complex loop with initialization, condition, and step.
The most commonly used loop in JavaScript.
Example:
javascript
Copy code
for (let i = 0; i < 3; i++) {
  alert(i);
}
Key Concepts:
Inline variable declaration: Declaring variables inside the loop (let i = 0) limits their scope to the loop itself.
Skipping parts of for: You can omit any part of the for loop (begin, condition, step).
Breaking the loop: Use the break statement to exit a loop early. Example:
javascript
Copy code
while (true) {
  let value = +prompt("Enter a number", '');
  if (!value) break; // Exits the loop if no value is entered.
}
Continuing to the next iteration: The continue statement skips the current iteration and moves to the next one. Example:
javascript
Copy code
for (let i = 0; i < 10; i++) {
  if (i % 2 == 0) continue;
  alert(i); // Outputs odd numbers
}
Labels for breaking/continuing nested loops: Labels allow you to break or continue nested loops. Example:
javascript
Copy code
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    let input = prompt(`Value at coords (${i},${j})`, '');
    if (!input) break outer; // Exits both loops.
  }
}
Summary:
while and do...while loops are used when the number of iterations is unknown beforehand.
The for loop is commonly used when the number of iterations is known.
You can break out of a loop early using break, and skip an iteration with continue.
Labels are used to break or continue from nested loops.
This structure gives flexibility for handling a variety of looping scenarios in JavaScript.

Function Declaration:
Functions in JavaScript are declared using the function keyword followed by a name, parameters (if any), and the body of the function (code to be executed).
Example:
javascript
Copy code
function showMessage() {
  alert('Hello everyone!');
}
showMessage(); // Calls the function

2. Local Variables:
Variables declared inside a function are local and only accessible within that function.
Example:
javascript
Copy code
function showMessage() {
  let message = 'Hello, I\'m JavaScript!';
  alert(message);
}
showMessage(); // Works fine
alert(message); // Error! `message` is local to the function
3. Outer Variables:
A function can access variables from the outer scope (global scope), and even modify them if necessary.
If a local variable has the same name as an outer variable, the local variable shadows the outer variable within the function.
Example:
javascript
Copy code
let userName = 'John';
function showMessage() {
  let userName = 'Bob'; // local variable
  alert('Hello, ' + userName); // Uses the local userName ('Bob')
}
showMessage();
alert(userName); // 'John' (the global variable is unchanged)
4. Global Variables:
Variables declared outside of any function are global and accessible from anywhere in the script.
It's generally good practice to minimize the use of global variables to avoid unintended consequences.
5. Parameters and Arguments:
Functions can accept parameters which act as placeholders for values passed to the function when called. These values are called arguments.
Example:
javascript
Copy code
function showMessage(from, text) {
  alert(from + ": " + text);
}
showMessage('Ann', 'Hello!'); // Ann: Hello!
6. Default Parameters:
If a parameter is not provided during the function call, it can be assigned a default value.
Example:
javascript
Copy code
function showMessage(from, text = 'no text given') {
  alert(from + ": " + text);
}
showMessage('Ann'); // Ann: no text given
7. Returning Values:
A function can return a value to the caller using the return keyword.
Example:
javascript
Copy code
function sum(a, b) {
  return a + b;
}
let result = sum(1, 2);
alert(result); // 3

8. Naming Functions:
Function names should clearly describe the action performed by the function. Common prefixes for naming functions are:
get...: to retrieve a value
calc...: to perform a calculation
create...: to create something
check...: to check something
Example function names:
showMessage(): shows a message
getAge(): returns an age value
calcSum(): calculates a sum
9. Functions Should Do One Thing:
A function should perform a single action as suggested by its name. Avoid combining multiple unrelated actions in a single function.
Example: Instead of writing a function that both checks age and displays a message, split them into two distinct functions.
10. Short Function Names:
Common libraries, like jQuery and Lodash, sometimes use very short function names like $ and _, respectively, for frequently used functions. However, most of the time, function names should be concise but descriptive.
11. Functions as Comments:
A well-named function can often serve as a self-describing comment, making the code more readable and maintainable.
Example:
javascript
Copy code
function showPrimes(n) {
  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;
    alert(i);  // prime number
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if (n % i == 0) return false;
  }
  return true;
}
Summary:
Functions are essential for making code modular, reusable, and easy to maintain.
They should have clear, descriptive names, typically starting with verbs (e.g., show, get, create).
Functions should focus on doing a single task. If more tasks are required, split them into separate functions.

Function expressions
In JavaScript, a function is not a “magical language structure”, but a special kind of value.

The syntax that we used before is called a Function Declaration:

function sayHi() {
  alert( "Hello" );
}
There is another syntax for creating a function that is called a Function Expression.

It allows us to create a new function in the middle of any expression.

For example:

let sayHi = function() {
  alert( "Hello" );
};
Here we can see a variable sayHi getting a value, the new function, created as function() { alert("Hello"); }.

As the function creation happens in the context of the assignment expression (to the right side of =), this is a Function Expression.

Please note, there’s no name after the function keyword. Omitting a name is allowed for Function Expressions.

Here we immediately assign it to the variable, so the meaning of these code samples is the same: “create a function and put it into the variable sayHi”.

In more advanced situations, that we’ll come across later, a function may be created and immediately called or scheduled for a later execution, not stored anywhere, thus remaining anonymous.

Function is a value
Let’s reiterate: no matter how the function is created, a function is a value. Both examples above store a function in the sayHi variable.

We can even print out that value using alert:

function sayHi() {
  alert( "Hello" );
}

alert( sayHi ); // shows the function code
Please note that the last line does not run the function, because there are no parentheses after sayHi. There are programming languages where any mention of a function name causes its execution, but JavaScript is not like that.

In JavaScript, a function is a value, so we can deal with it as a value. The code above shows its string representation, which is the source code.

Surely, a function is a special value, in the sense that we can call it like sayHi().

But it’s still a value. So we can work with it like with other kinds of values.

We can copy a function to another variable:

function sayHi() {   // (1) create
  alert( "Hello" );
}

let func = sayHi;    // (2) copy

func(); // Hello     // (3) run the copy (it works)!
sayHi(); // Hello    //     this still works too (why wouldn't it)
Here’s what happens above in detail:

The Function Declaration (1) creates the function and puts it into the variable named sayHi.
Line (2) copies it into the variable func. Please note again: there are no parentheses after sayHi. If there were, then func = sayHi() would write the result of the call sayHi() into func, not the function sayHi itself.
Now the function can be called as both sayHi() and func().
We could also have used a Function Expression to declare sayHi, in the first line:

let sayHi = function() { // (1) create
  alert( "Hello" );
};

let func = sayHi;
// ...
Everything would work the same.

Why is there a semicolon at the end?
You might wonder, why do Function Expressions have a semicolon ; at the end, but Function Declarations do not:

function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
};
The answer is simple: a Function Expression is created here as function(…) {…} inside the assignment statement: let sayHi = …;. The semicolon ; is recommended at the end of the statement, it’s not a part of the function syntax.

The semicolon would be there for a simpler assignment, such as let sayHi = 5;, and it’s also there for a function assignment.

Callback functions
Let’s look at more examples of passing functions as values and using function expressions.

We’ll write a function ask(question, yes, no) with three parameters:

question
Text of the question
yes
Function to run if the answer is “Yes”
no
Function to run if the answer is “No”
The function should ask the question and, depending on the user’s answer, call yes() or no():

function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "You agreed." );
}

function showCancel() {
  alert( "You canceled the execution." );
}

// usage: functions showOk, showCancel are passed as arguments to ask
ask("Do you agree?", showOk, showCancel);
In practice, such functions are quite useful. The major difference between a real-life ask and the example above is that real-life functions use more complex ways to interact with the user than a simple confirm. In the browser, such functions usually draw a nice-looking question window. But that’s another story.

The arguments showOk and showCancel of ask are called callback functions or just callbacks.

The idea is that we pass a function and expect it to be “called back” later if necessary. In our case, showOk becomes the callback for “yes” answer, and showCancel for “no” answer.

We can use Function Expressions to write an equivalent, shorter function:

function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Do you agree?",
  function() { alert("You agreed."); },
  function() { alert("You canceled the execution."); }
);
Here, functions are declared right inside the ask(...) call. They have no name, and so are called anonymous. Such functions are not accessible outside of ask (because they are not assigned to variables), but that’s just what we want here.

Such code appears in our scripts very naturally, it’s in the spirit of JavaScript.

A function is a value representing an “action”
Regular values like strings or numbers represent the data.

A function can be perceived as an action.

We can pass it between variables and run when we want.

Function Expression vs Function Declaration
Let’s formulate the key differences between Function Declarations and Expressions.

First, the syntax: how to differentiate between them in the code.

Function Declaration: a function, declared as a separate statement, in the main code flow:

// Function Declaration
function sum(a, b) {
  return a + b;
}
Function Expression: a function, created inside an expression or inside another syntax construct. Here, the function is created on the right side of the “assignment expression” =:

// Function Expression
let sum = function(a, b) {
  return a + b;
};
The more subtle difference is when a function is created by the JavaScript engine.

A Function Expression is created when the execution reaches it and is usable only from that moment.

Once the execution flow passes to the right side of the assignment let sum = function… – here we go, the function is created and can be used (assigned, called, etc. ) from now on.

Function Declarations are different.

A Function Declaration can be called earlier than it is defined.

For example, a global Function Declaration is visible in the whole script, no matter where it is.

That’s due to internal algorithms. When JavaScript prepares to run the script, it first looks for global Function Declarations in it and creates the functions. We can think of it as an “initialization stage”.

And after all Function Declarations are processed, the code is executed. So it has access to these functions.

For example, this works:

sayHi("John"); // Hello, John

function sayHi(name) {
  alert( `Hello, ${name}` );
}
The Function Declaration sayHi is created when JavaScript is preparing to start the script and is visible everywhere in it.

…If it were a Function Expression, then it wouldn’t work:

sayHi("John"); // error!

let sayHi = function(name) {  // (*) no magic any more
  alert( `Hello, ${name}` );
};
Function Expressions are created when the execution reaches them. That would happen only in the line (*). Too late.

Another special feature of Function Declarations is their block scope.

In strict mode, when a Function Declaration is within a code block, it’s visible everywhere inside that block. But not outside of it.

For instance, let’s imagine that we need to declare a function welcome() depending on the age variable that we get during runtime. And then we plan to use it some time later.

If we use Function Declaration, it won’t work as intended:

let age = prompt("What is your age?", 18);

// conditionally declare a function
if (age < 18) {

  function welcome() {
    alert("Hello!");
  }

} else {

  function welcome() {
    alert("Greetings!");
  }

}

// ...use it later
welcome(); // Error: welcome is not defined
That’s because a Function Declaration is only visible inside the code block in which it resides.

Here’s another example:

let age = 16; // take 16 as an example

if (age < 18) {
  welcome();               // \   (runs)
                           //  |
  function welcome() {     //  |
    alert("Hello!");       //  |  Function Declaration is available
  }                        //  |  everywhere in the block where it's declared
                           //  |
  welcome();               // /   (runs)

} else {

  function welcome() {
    alert("Greetings!");
  }
}

// Here we're out of curly braces,
// so we can not see Function Declarations made inside of them.

welcome(); // Error: welcome is not defined
What can we do to make welcome visible outside of if?

The correct approach would be to use a Function Expression and assign welcome to the variable that is declared outside of if and has the proper visibility.

This code works as intended:

let age = prompt("What is your age?", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Hello!");
  };

} else {

  welcome = function() {
    alert("Greetings!");
  };

}

welcome(); // ok now
Or we could simplify it even further using a question mark operator ?:

let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  function() { alert("Hello!"); } :
  function() { alert("Greetings!"); };

welcome(); // ok now
When to choose Function Declaration versus Function Expression?
As a rule of thumb, when we need to declare a function, the first thing to consider is Function Declaration syntax. It gives more freedom in how to organize our code, because we can call such functions before they are declared.

That’s also better for readability, as it’s easier to look up function f(…) {…} in the code than let f = function(…) {…};. Function Declarations are more “eye-catching”.

…But if a Function Declaration does not suit us for some reason, or we need a conditional declaration (we’ve just seen an example), then Function Expression should be used.

Summary
Functions are values. They can be assigned, copied or declared in any place of the code.
If the function is declared as a separate statement in the main code flow, that’s called a “Function Declaration”.
If the function is created as a part of an expression, it’s called a “Function Expression”.
Function Declarations are processed before the code block is executed. They are visible everywhere in the block.
Function Expressions are created when the execution flow reaches them.
In most cases when we need to declare a function, a Function Declaration is preferable, because it is visible prior to the declaration itself. That gives us more flexibility in code organization, and is usually more readable.

So we should use a Function Expression only when a Function Declaration is not fit for the task. We’ve seen a couple of examples of that in this chapter, and will see more in the future.

Basic Arrow Function Syntax:
The syntax is more compact than traditional function expressions.
Instead of function, you use => (an arrow) to define the function.
javascript
Copy code
let sum = (a, b) => a + b;  // Short form for sum function
alert(sum(1, 2));  // 3
This is equivalent to the traditional function expression:

javascript
Copy code
let sum = function(a, b) {
  return a + b;
};
alert(sum(1, 2));  // 3
2. Single Argument (No Parentheses Needed):
If there's only one argument, parentheses around it can be omitted.
javascript
Copy code
let double = n => n * 2;  // Same as: let double = function(n) { return n * 2; }
alert(double(3));  // 6
3. No Arguments (Empty Parentheses Required):
If there are no arguments, you must include empty parentheses.
javascript
Copy code
let sayHi = () => alert("Hello!");
sayHi();  // Hello!
4. Multiline Arrow Functions:
If you need to write more complex functions with multiple expressions, you can use curly braces {}.
You must use the return statement explicitly to return a value from a function.
javascript
Copy code
let sum = (a, b) => {
  let result = a + b;
  return result;  // Explicit return is needed when using curly braces
};
alert(sum(1, 2));  // 3
5. Arrow Functions in Conditional Logic:
Arrow functions can also be used in conditional statements or to define functions dynamically, like in this example:
javascript
Copy code
let age = prompt("What is your age?", 18);
let welcome = (age < 18) ? () => alert('Hello!') : () => alert("Greetings!");
welcome();  // Displays a greeting based on the age
6. Summary:
Without curly braces: (arg1, arg2) => expression – evaluates and returns the result of the expression.
With curly braces: (arg1, arg2) => { body } – allows multiple statements, but you need an explicit return to return a value.
Arrow functions are perfect for concise code, especially in cases like callbacks or simple calculations, and they help improve the readability and efficiency of your code.


Chapter 4 Objects the basics

Creating Objects
Objects are collections of key-value pairs, where keys are strings and values can be any data type.
You can create objects using either:
js
Copy code
let user = new Object();  // object constructor
let user = {};            // object literal (commonly used)
2. Properties
You can define properties using the syntax:
js
Copy code
let user = {
  name: "John",
  age: 30
};
Access properties using dot notation (user.name) or square brackets (user["name"]).
3. Adding/Removing Properties
Add properties:
js
Copy code
user.isAdmin = true;
Remove properties:
js
Copy code
delete user.age;
4. Multiword Property Names
For multi-word property names, you must use square bracket notation:
js
Copy code
let user = { "likes birds": true };
5. Computed Properties
You can use expressions inside square brackets to define properties:
js
Copy code
let fruit = "apple";
let bag = { [fruit]: 5 };  // bag.apple = 5
6. Property Shorthand
When variable names and property names are the same, you can use shorthand:
js
Copy code
function makeUser(name, age) {
  return { name, age };  // shorthand for name: name, age: age
}
7. Special Property Names
Property names can include reserved keywords like for, let, and return:
js
Copy code
let obj = { for: 1, let: 2, return: 3 };
8. Accessing Non-Existent Properties
JavaScript will not throw an error when accessing a non-existent property; instead, it returns undefined.
You can check for existence using the "in" operator:
js
Copy code
"name" in user;  // true if "name" exists
9. The for..in Loop
Use for..in to iterate over all keys in an object:
js
Copy code
for (let key in user) {
  alert(key);  // alerts each property name
}
10. Property Order
Integer keys are sorted in ascending order, while string keys retain the order in which they were added to the object.
11. Summary
Objects are versatile and allow storing key-value pairs.
They support dot and square bracket notation for accessing properties, and various operations such as adding, removing, and checking for properties.
Objects are a core feature of JavaScript and understanding them thoroughly is essential. You can manipulate data effectively by using objects to store structured information in the form of properties.

Primitive vs. Object Assignment:
Primitives (like strings, numbers, booleans) are copied by value. When you assign one primitive to another, they are completely independent.
Objects, however, are assigned and copied by reference. This means that when you assign an object to another variable, both variables point to the same object in memory.
2. Object Reference:
When you assign an object to a variable, that variable holds a reference (memory address) to the object, not a copy of the object itself.
If you modify the object through one variable, the changes will be reflected in the other variable since both refer to the same object.
3. Comparison by Reference:
Two objects are equal only if they reference the same memory address. Even if they contain the same properties, they are not considered equal if they refer to different memory locations.
4. Modifying const Objects:
When you declare an object as const, you can still modify its properties. The const keyword only prevents reassigning the variable to a different object, not altering the properties of the object.
5. Cloning Objects:
Shallow copy (like using Object.assign) creates a new object, but nested objects are still copied by reference, not duplicated.
Deep copy (like using structuredClone) ensures that all nested objects are also copied by value, so changes to nested objects do not affect the original object.
6. Structured Cloning:
The structuredClone method can deeply clone objects, handling circular references and most data types, but it does not support cloning function properties.
7. Lodash _.cloneDeep:
For complex cases where deep cloning is needed, especially for objects with functions or other advanced structures, libraries like Lodash offer a deep cloning function (_.cloneDeep), which handles more cases than the built-in structuredClone.
Summary:
Understanding how JavaScript handles object references and cloning is crucial when working with objects to avoid unintended side effects, especially when dealing with nested structures. For most use cases:

Use Object.assign for shallow copies.
Use structuredClone or a library like Lodash for deep cloning when necessary.

Methods in Objects:
A method is a function that is a property of an object.
You can define methods directly inside an object:
js
Copy code
let user = {
  name: "John",
  sayHi() { // Method shorthand
    alert("Hello!");
  }
};
user.sayHi(); // Hello!
Methods allow objects to perform actions, such as logging in, logging out, or performing calculations.
2. this Keyword in Methods:
In object methods, this refers to the object that called the method. It helps access the properties of the object.
In the example:
js
Copy code
let user = {
  name: "John",
  sayHi() {
    alert(this.name); // `this` refers to the `user` object
  }
};
user.sayHi(); // John
this refers to the object (user in this case) that called the method.
3. Method Shorthand:
There’s a shorthand syntax for defining methods inside an object:
js
Copy code
let user = {
  sayHi() {
    alert("Hello");
  }
};
This is a more concise way to write methods, and in most cases, it is preferred.
4. Understanding this Context:
The value of this is determined at runtime when the method is called, not at the time it’s defined.
When calling a method like object.method(), this inside the method refers to object.
Example:

js
Copy code
let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert(this.name);
}

user.f = sayHi;
admin.f = sayHi;

user.f(); // John
admin.f(); // Admin
Here, this refers to the object that calls the method, which can be user or admin.

5. Calling Functions Without an Object:
If a function is called without an object (e.g., sayHi()), this will be undefined in strict mode.
In non-strict mode, this would refer to the global object (in a browser, it's window).
Example in strict mode:

js
Copy code
'use strict';
function sayHi() {
  alert(this); // undefined
}
sayHi();
Without strict mode:

js
Copy code
function sayHi() {
  alert(this); // window (global object)
}
sayHi();
6. Arrow Functions and this:
Arrow functions do not have their own this. Instead, they inherit this from the outer function where they are defined.
This is useful in certain cases, where you want the this from the outer context to be used inside the arrow function.
Example:

js
Copy code
let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName); // `this` comes from outer sayHi method
    arrow();
  }
};

user.sayHi(); // Ilya
Summary:
Methods are functions stored as object properties.
this inside a method refers to the object that calls the method.
Method shorthand makes object method definitions more concise.
this is evaluated at runtime, depending on the calling context.
Arrow functions do not have their own this; they inherit it from the surrounding context.
Understanding this is crucial when working with objects and methods in JavaScript, as it determines which object the method operates on.

Constructor Functions:
Constructor functions are regular functions, but they are conventionally named with a capital letter to distinguish them from regular functions.
When a function is executed with the new operator, it creates a new object and assigns it to this, then adds properties to this.
Example:

js
Copy code
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Jack");
alert(user.name);  // Jack
alert(user.isAdmin);  // false
The new operator creates a new object, which gets assigned to this, and then the function populates it with properties.

2. How the new Operator Works:
When you call a function with new, JavaScript follows these steps:
Creates a new empty object.
Sets the context (this) to the new object.
The function's code runs, and properties are added to this.
The new object (this) is returned, unless the constructor explicitly returns a different object.
The constructor function essentially allows you to create multiple instances of objects, each with their own properties.

Example of using the new operator:

js
Copy code
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user1 = new User("Alice");
let user2 = new User("Bob");
alert(user1.name);  // Alice
alert(user2.name);  // Bob
3. Constructor Mode and new.target:
Inside a constructor function, the new.target property tells you whether the function was called with new or not.
If the function was called with new, new.target will reference the function itself.
If called without new, new.target will be undefined.
Example:

js
Copy code
function User() {
  alert(new.target);
}

User();  // undefined (called without new)
new User();  // function User { ... } (called with new)
You can also use new.target to make the function behave like a constructor even if it’s called without new, by automatically redirecting the call to new.

Example:

js
Copy code
function User(name) {
  if (!new.target) {  // If not called with `new`
    return new User(name);  // Redirect call to `new`
  }

  this.name = name;
}

let user = User("John");  // Automatically calls `new User("John")`
alert(user.name);  // John
4. Return Values in Constructors:
Constructors normally don’t have a return statement. The this object created by new is automatically returned.
If a constructor explicitly returns an object, that object is returned instead of the this object.
If the constructor returns a primitive value, it is ignored, and this is still returned.
Example where the return overrides this:

js
Copy code
function BigUser() {
  this.name = "John";
  return { name: "Godzilla" };  // This object is returned instead of `this`
}

let user = new BigUser();
alert(user.name);  // Godzilla
Example where this is returned:

js
Copy code
function SmallUser() {
  this.name = "John";
  return;  // No return value, `this` is returned
}

let user = new SmallUser();
alert(user.name);  // John
5. Omitting Parentheses:
You can omit parentheses when calling a constructor function with new. The following are equivalent:
js
Copy code
let user1 = new User("John");
let user2 = new User;  // No parentheses
Omitting parentheses is allowed, but it’s generally not considered good practice.

6. Methods in Constructors:
Constructor functions can also include methods that objects created from them can use.
These methods are added to the object, just like properties.
Example:

js
Copy code
function User(name) {
  this.name = name;
  this.sayHi = function() {
    alert("My name is: " + this.name);
  };
}

let john = new User("John");
john.sayHi();  // My name is: John
Summary:
Constructor functions allow for creating multiple instances of objects with shared properties and methods.
The new operator initializes a new object, sets this to that object, and returns it.
new.target can be used to check if a function was called with new or not, and to redirect calls if necessary.
Constructors can return objects, but the returned object will override the default this object.
Constructor functions can also have methods that operate on the object's properties.
Constructor functions are a foundational concept in JavaScript, enabling reusable object creation and helping implement object-oriented principles.

The optional chaining (?.) operator in JavaScript is a powerful feature that helps handle cases where intermediate properties in an object may not exist, avoiding errors without the need for repetitive checks. Here’s a breakdown of how it works and its key points:

The Problem:
In JavaScript, accessing nested properties without checking each level for existence can result in errors. For example:

js
Copy code
let user = {}; // user has no "address" property
alert(user.address.street); // Error: Cannot read property 'street' of undefined
This is problematic, especially in cases where some properties might be missing.

The Solution: Optional Chaining
The optional chaining (?.) operator solves this problem. It allows safe access to deeply nested properties and methods, returning undefined instead of throwing an error if the value before the ?. is null or undefined.

Basic Example:
If we want to safely access user.address.street even if user.address is undefined:

js
Copy code
let user = {}; // user has no "address" property
alert(user?.address?.street); // undefined (no error)
Instead of throwing an error, this returns undefined when user.address doesn't exist.

Use Cases:
Accessing Properties: The ?. operator checks if the left-hand value is null or undefined. If it is, the whole expression returns undefined; otherwise, it proceeds to access the property or method.

Example:

js
Copy code
let user = { address: { street: 'Main St' } };
alert(user?.address?.street); // Main St

let user2 = {};
alert(user2?.address?.street); // undefined
With Functions or Methods: If a function or method might not exist on an object, you can use optional chaining to avoid errors:

js
Copy code
let userAdmin = { admin() { alert('Admin'); } };
let userGuest = {};
userAdmin.admin?.(); // Admin
userGuest.admin?.(); // Nothing happens
With Arrays and Brackets: Optional chaining also works with bracket notation, useful for accessing dynamic property names:

js
Copy code
let user = { firstName: 'John' };
let key = 'firstName';
alert(user?.[key]); // John

let user2 = null;
alert(user2?.[key]); // undefined
With Delete: You can safely use optional chaining with delete to delete properties if they exist:

js
Copy code
let user = { name: 'John' };
delete user?.name; // Deletes user.name if user exists
Key Points:
Prevents Errors: It avoids runtime errors caused by accessing properties on null or undefined values.
Short-circuiting: If the value before ?. is null or undefined, the operation stops, and undefined is returned.
Nested Properties: You can chain multiple ?. operators to safely access deeply nested properties.
js
Copy code
let user = {};
alert(user?.address?.street?.name); // undefined
Works with Functions: Use ?.() to safely call functions that may not be defined.
Does Not Work on Left of Assignment: It cannot be used for assignments or writes, such as user?.name = "John".
When to Use Optional Chaining:
Optional chaining should be used when:

You expect that some properties might not exist and it’s acceptable for them to be undefined in such cases.
You want to avoid repetitive if checks for each level of a deeply nested structure.
Limitations:
Avoid Overuse: Overusing optional chaining can silence programming errors that you may want to catch, especially when a property is critical for the logic.
Declared Variables Only: The variable must be declared (e.g., let user or const user), as attempting to access a non-declared variable with ?. will cause an error.
Summary:
Optional chaining (?.) is a concise and efficient way to handle cases where a property or method might not exist. It allows you to avoid verbose if checks and reduces the chance of runtime errors. However, it should be used judiciously, only when it’s acceptable for a value to be undefined without causing issues in your program.

he Symbol type in JavaScript represents a unique identifier. Here’s a summary of its key features:

Key Characteristics of Symbols:
Uniqueness: Each symbol is guaranteed to be unique, even if it has the same description. For example, Symbol("id") !== Symbol("id"), even though both have the same name.

Non-Auto Conversion: Symbols do not auto-convert to strings. For instance, attempting to directly print a symbol with alert(id) results in a TypeError. To display the symbol, you need to explicitly convert it using .toString() or access its description using id.description.

“Hidden” Properties: Symbols allow you to add properties to objects that other code won’t accidentally access or overwrite. This is particularly useful when working with objects that are part of third-party code.

Example:

javascript
Copy code
let user = { name: "John" };
let id = Symbol("id");
user[id] = 123;
alert(user[id]); // 123
Symbolic Properties in Objects: You can use symbols as property keys in object literals, but you need to wrap the symbol in square brackets.

Example:

javascript
Copy code
let user = {
  name: "John",
  [id]: 123
};
Symbols in Iteration: Symbol properties are not included in for..in loops or Object.keys(). This helps prevent unintended access to symbolic properties, ensuring that they remain hidden unless explicitly accessed.

Global Symbol Registry: Symbols can be created globally via Symbol.for(key), which ensures that repeated access to the same symbol by name returns the same instance of the symbol. This is useful when you need to share symbols across different parts of an application.

Example:

javascript
Copy code
let id = Symbol.for("id");
let idAgain = Symbol.for("id");
alert(id === idAgain); // true
Symbol Methods:

Symbol.keyFor(symbol): Retrieves the name (key) of a global symbol.
Object.getOwnPropertySymbols(obj): Returns an array of all symbol properties in an object.
Reflect.ownKeys(obj): Returns all keys (including symbols) of an object.
System Symbols: JavaScript has a number of built-in symbols (such as Symbol.iterator, Symbol.toPrimitive, etc.) that are used for system-level behaviors. These symbols can be accessed and used to fine-tune how objects behave in certain operations.

Use Cases:
Hidden object properties: Symbols allow you to safely add properties to objects that should not be accidentally modified or accessed by other code.
Global Symbols: For sharing the same symbol across different modules or parts of an application, using Symbol.for(key) ensures that the same symbol is used consistently.
Example of Symbol Usage:
javascript
Copy code
let user = { name: "John" };
let id = Symbol("id");

user[id] = 123; // Adding a "hidden" property

// Accessing the symbol property directly
alert(user[id]); // 123

// Iteration ignores symbolic properties
for (let key in user) {
  console.log(key); // name
}

// Cloning an object retains symbol properties
let clone = Object.assign({}, user);
alert(clone[id]); // 123
By using symbols, you can protect your code from naming conflicts and ensure that certain properties remain "hidden" and are not accidentally accessed or overwritten.

In JavaScript, when we perform operations like adding (obj1 + obj2), subtracting (obj1 - obj2), or printing (alert(obj)), objects are automatically converted into primitive values (like numbers or strings) for those operations. JavaScript doesn’t allow us to customize how operators work directly on objects.

Key Points:
No math with objects: Operations on objects like addition won’t result in another object; they result in a primitive value (like a number or string).

Conversion Rules:

Objects are converted to either a string or a number, depending on the operation.
The conversion is done based on "hints" that determine whether the object should be converted to a string ("string") or a number ("number").
Methods for Conversion: JavaScript first checks if an object has a special method called Symbol.toPrimitive for conversion. If it doesn’t, it tries toString or valueOf, depending on whether it needs a string or number.

Custom Conversion: You can define how an object should be converted by implementing Symbol.toPrimitive, toString, or valueOf methods in your object.

Example:

If you add an object with a number, JavaScript will call toString or valueOf to convert the object into a string or number before doing the operation.
Important: The methods must return a primitive (a number, string, or boolean) and not another object. If they return an object, it’s ignored or causes an error, depending on the method used.

In simple terms: JavaScript automatically converts objects into strings or numbers when necessary for operations, and you can control this conversion by defining special methods in your objects.

Chapter 5 Data types
In JavaScript, primitives (like strings, numbers, booleans) are simple values and don’t have methods or properties. However, when you try to call a method on a primitive, JavaScript temporarily wraps the primitive in a special object wrapper (like String, Number, Boolean) that provides those methods, and then the wrapper is discarded after the operation.

Key Differences:
Primitives are simple values and can’t store multiple values or functions. Examples include string, number, boolean, null, undefined, symbol, and bigint.
Objects are more complex and can store multiple values and functions as properties. They are "heavier" because they require more resources.
How it works:
When you call a method on a primitive (like "hello".toUpperCase()), JavaScript creates a temporary object (in this case, a String object) that holds the primitive value and has the toUpperCase method. After the method runs, the temporary object is destroyed, leaving the primitive value unchanged.
Examples:
String method:

javascript
Copy code
let str = "hello";
alert(str.toUpperCase()); // "HELLO"
// The primitive string is wrapped in a String object temporarily.
Number method:

javascript
Copy code
let num = 1.23456;
alert(num.toFixed(2)); // 1.23
Constructors (String, Number, Boolean):
You can create wrapper objects with new String(), new Number(), or new Boolean(), but this is discouraged because these are treated as objects, which can lead to unexpected behavior.
javascript
Copy code
let zero = new Number(0);
alert(typeof zero); // "object" (not "number")
if (zero) {
  alert("zero is truthy!?!");
}
It’s better to use the functions (String(), Number(), Boolean()) without new to convert values to the corresponding primitive type:
javascript
Copy code
let num = Number("123"); // 123 (primitive number)
Special cases:
null and undefined are exceptions. They don’t have methods or wrapper objects. Trying to call a method on them will result in an error:
javascript
Copy code
alert(null.test); // error
Summary:
Primitives (like strings and numbers) can be used with methods, but JavaScript internally wraps them in temporary objects for the operation, and then discards the wrapper.
Wrapper objects (String, Number, Boolean) can be used for methods, but creating them with new is not recommended.
null and undefined have no methods and are the most "primitive" types.

Types of Numbers in JavaScript
Regular Numbers: Stored as 64-bit IEEE-754 double precision floating point values. Most of the numbers used in JavaScript are of this type.
BigInt Numbers: For integers larger than what can be safely represented by regular numbers (beyond ±2^53-1).
Ways to Write Numbers
Underscores for Readability: You can use underscores (_) as separators in large numbers for readability.

js
Copy code
let billion = 1_000_000_000;
Scientific Notation: You can use e to represent very large or small numbers.

js
Copy code
let billion = 1e9;  // 1 billion
let mcs = 1e-6;     // 1 millionth (microsecond)
Different Numeral Systems
Hexadecimal: Prefixed with 0x:

js
Copy code
alert(0xff);  // 255
Binary: Prefixed with 0b:

js
Copy code
let a = 0b11111111; // 255 in binary
Octal: Prefixed with 0o:

js
Copy code
let b = 0o377; // 255 in octal
toString(base) Method
Converts numbers to a string representation in a specified base (from 2 to 36). For example:
js
Copy code
let num = 255;
console.log(num.toString(16));  // "ff" (hexadecimal)
console.log(num.toString(2));   // "11111111" (binary)
Rounding Methods
Math.floor: Rounds down.
Math.ceil: Rounds up.
Math.round: Rounds to the nearest integer.
Math.trunc: Removes decimals (no rounding).
Rounding to Specific Digits
You can round to n decimal places using toFixed(n) or by multiplying and dividing:
js
Copy code
let num = 1.23456;
console.log(Math.round(num * 100) / 100); // 1.23
console.log(num.toFixed(2)); // "1.23" (returns string)
Imprecise Calculations
Due to the binary representation of numbers, you might encounter imprecision in operations like 0.1 + 0.2. This happens because numbers like 0.1 and 0.2 are not exactly representable in binary.

Special Numeric Values
Infinity: Represents numbers too large to be handled.
NaN: Represents a computational error or invalid result.
isNaN() and isFinite() Functions
isNaN(value) checks if the value is NaN.
isFinite(value) checks if the value is a valid finite number.
Number.isNaN() and Number.isFinite()
These are stricter versions of isNaN and isFinite and don't perform type conversion.

Comparison of Values with Object.is()
Object.is(a, b) is like === but handles edge cases with NaN and -0 more reliably.
Parsing Numbers with parseInt() and parseFloat()
parseInt() parses a string and returns an integer.
parseFloat() parses a string and returns a floating-point number.
Other Math Functions
Math.random(): Returns a random number between 0 (inclusive) and 1 (exclusive).
Math.max() and Math.min(): Find the largest and smallest numbers, respectively.
Math.pow(): Returns a number raised to a power.

In JavaScript, strings are used for textual data and are stored in UTF-16 format. You can enclose strings in single quotes, double quotes, or backticks. Backticks allow for multi-line strings and embedding expressions inside ${}.

Special Characters:
\n - New line
\t - Tab
\\ - Backslash
\' or \" - Quotes
Unicode characters can be represented with \u….
String Methods:
.length - Gets the string length.
.at(pos) - Accesses characters by index, allowing negative values for positions from the end.
.toUpperCase(), .toLowerCase() - Change case.
.indexOf(), .includes(), .startsWith(), .endsWith() - Search for substrings.
.slice(), .substring(), .substr() - Extract parts of a string.
.localeCompare() - Compares strings according to language rules.
Notes:
Strings are immutable (cannot be modified directly).
Special characters like newline (\n) or escape sequences (\\) are used to represent special characters in strings.
To compare strings correctly considering language rules, use localeCompare.
In short, JavaScript strings are versatile with various methods for manipulation, but they're immutable and based on Unicode encoding.

Key Features of Arrays in JavaScript:
Array Declaration:

Arrays can be created using the syntax let arr = [] or let arr = new Array().
Arrays can store various types of elements, including objects, functions, and primitives.
Accessing and Modifying Elements:

Array elements are accessed by index: arr[0], arr[1], etc.
You can modify elements using their index, e.g., arr[2] = "New value".
Arrays are dynamic and can grow by appending elements to the end.
Array Length:

arr.length returns the number of elements in the array. It automatically updates when elements are added or removed.
Adding/Removing Elements:

push(): Adds elements to the end of the array.
pop(): Removes the last element of the array.
shift(): Removes the first element of the array.
unshift(): Adds elements to the beginning of the array.
Methods for Negative Indexes:

at(): Allows negative indexes, such as arr.at(-1), to access elements from the end of the array.
Performance Considerations:

Operations on the end of the array (like push and pop) are faster than operations on the beginning (like shift and unshift) because shifting elements around can be expensive for large arrays.
Looping through Arrays:

Use for (let i = 0; i < arr.length; i++) for traditional looping.
for...of loop provides a concise syntax when you need to work with values.
for...in loop should be avoided with arrays because it iterates over all properties, including non-numeric ones.
Comparison of Arrays:

Arrays should not be compared directly using == or === because these operators check for reference equality.
Use a custom method to compare arrays element-by-element if necessary.
Array Misuse:

Arrays should not be treated as objects by adding non-numeric properties or using large gaps in indices, as this disables internal optimizations.
Multidimensional Arrays:

Arrays can contain other arrays, creating multi-dimensional structures, like matrices.
Conclusion:
Arrays are powerful tools in JavaScript for managing ordered collections of data, but they should be used with care, especially considering performance implications and avoiding misuse. The right operations (such as using push and pop for stacks or shift and unshift for queues) can help keep your code efficient.

This is a comprehensive overview of various array methods in JavaScript that help manipulate and transform arrays in different ways. Below is a summarized breakdown:

Add/Remove Items:
arr.push(...items): Adds items to the end.
arr.pop(): Removes and returns an item from the end.
arr.shift(): Removes and returns an item from the beginning.
arr.unshift(...items): Adds items to the beginning.
Deleting and Modifying Elements:
arr.splice(start[, deleteCount, elem1, ..., elemN]):
Removes deleteCount items from the start index and inserts new elements.
Can also be used to insert items without removal by setting deleteCount to 0.
Returns an array of removed elements.
Slicing and Concatenating:
arr.slice([start], [end]):
Returns a shallow copy of a portion of the array, from start to end (exclusive).
Supports negative indexes for positions from the end.
arr.concat(arg1, arg2...):
Creates a new array combining the current array with one or more arrays or values.
Iteration:
arr.forEach(): Executes a function on each element of the array.
arr.indexOf(item): Returns the index of the first occurrence of item.
arr.includes(item): Checks if the array contains the specified item.
Finding Elements:
arr.find(): Returns the first element that satisfies a condition.
arr.findIndex(): Returns the index of the first element that satisfies a condition.
arr.filter(): Returns an array of all elements that satisfy a condition.
Transforming Elements:
arr.map(): Returns a new array with the results of applying a function to each element.
arr.sort(): Sorts the array in place. Custom sorting can be done using a compare function.
arr.reverse(): Reverses the order of elements in the array.
arr.join(): Joins the array into a string using a specified delimiter.
Reducing:
arr.reduce(): Iterates through the array and accumulates a single result, like summing numbers.
arr.reduceRight(): Works the same as reduce, but iterates from right to left.
Special Methods:
arr.split(): Converts a string into an array based on a delimiter.
arr.slice() and arr.splice(): Used for slicing and modifying arrays respectively.
arr.sort(): Sorts arrays with custom comparators, especially useful for numbers and strings in different locales.
These methods can be combined for efficient data manipulation in JavaScript. Each has its use case depending on whether you're adding/removing items, searching for elements, transforming data, or reducing arrays to a single value.


Array Methods Cheat Sheet Summary:

Adding/Removing Elements:

push(...items) – adds items to the end.
pop() – removes an item from the end.
shift() – removes an item from the beginning.
unshift(...items) – adds items to the beginning.
splice(pos, deleteCount, ...items) – removes elements at position pos and inserts new ones.
slice(start, end) – creates a new array from start to end (non-inclusive).
concat(...items) – returns a new array by combining the current array and other items.
Searching Elements:

indexOf/lastIndexOf(item, pos) – finds the index of item starting from pos.
includes(value) – checks if the array contains value.
find/filter(func) – returns the first/all elements matching the condition in func.
findIndex(func) – returns the index of the first element that matches the condition.
Iterating Over Elements:

forEach(func) – calls func for each element (no return value).
Transforming Arrays:

map(func) – creates a new array from the results of func.
sort(func) – sorts the array in place.
reverse() – reverses the array in place.
split/join – convert a string to an array and vice versa.
reduce/reduceRight(func, initial) – accumulates a value based on array elements.
Other Useful Methods:

Array.isArray(value) – checks if value is an array.
some(fn)/every(fn) – checks if any/all elements satisfy the condition in fn.
fill(value, start, end) – fills the array with value from start to end.
copyWithin(target, start, end) – copies elements within the array.
flat(depth)/flatMap(fn) – flattens a multidimensional array.

Iterables in JavaScript

What are Iterables?

Iterables are objects that can be used with a for..of loop, enabling iteration over their elements.
Arrays, strings, and other built-in objects are iterables.
The key feature of an iterable is the Symbol.iterator method, which allows the object to be used in for..of loops.
Symbol.iterator

To make an object iterable, we define the method Symbol.iterator in the object.
The method should return an iterator object that has a next() method, which provides the iteration process.
The next() method should return an object with two properties:
done: Boolean – true when the iteration is finished, false otherwise.
value: any – the next value to be returned in the iteration.
Example of an Iterable:

javascript
Copy code
let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  alert(num); // 1, 2, 3, 4, 5
}
Symbol.iterator initializes the iteration, and next() generates the next value.
Infinite Iterators:

Iterators can be infinite, for example, generating an infinite sequence of numbers or pseudorandom values. The for..of loop can be stopped using break in such cases.
Strings are Iterable:

Strings are both iterable and array-like. Using for..of, you can iterate through each character of a string.
javascript
Copy code
for (let char of "test") {
  alert(char); // t, e, s, t
}
Explicit Iteration:

You can also manually control iteration by directly using the iterator:
javascript
Copy code
let str = "Hello";
let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // Outputs characters one by one
}
Array-likes vs. Iterables:

Array-like objects: Objects that have numeric indexes and a length property (e.g., arguments, NodeList) but do not have Symbol.iterator.
Iterable objects: Objects that implement the Symbol.iterator method.
For example, a range object is iterable but not array-like, while a string is both iterable and array-like.
Array.from:

Converts an iterable or array-like object into a real array.
javascript
Copy code
let arrayLike = { 0: "Hello", 1: "World", length: 2 };
let arr = Array.from(arrayLike); // Converts to array
alert(arr.pop()); // World
For iterables, like range, it creates an array from the sequence of values.
javascript
Copy code
let arr = Array.from(range);
alert(arr); // [1, 2, 3, 4, 5]
Optional Mapping with Array.from: You can also apply a mapping function to each element while converting.
javascript
Copy code
let arr = Array.from(range, num => num * num);
alert(arr); // [1, 4, 9, 16, 25]
Working with Surrogate Pairs:

Array.from works with surrogate pairs, ensuring proper handling of characters like emojis.
javascript
Copy code
let str = '𝒳😂';
let chars = Array.from(str);
alert(chars); // ['𝒳', '😂']
Summary:

Iterables implement Symbol.iterator, enabling use in for..of loops.
Iterators handle the iteration process with next(), which returns {done, value}.
Built-in iterables include arrays and strings.
Array.from() is used to convert iterables and array-likes into arrays, with an optional mapping function to modify values during conversion.

Map
Maps are key-value collections, where keys can be any data type (e.g., objects, numbers, booleans).
Unlike objects, where keys are converted to strings, Map preserves the type of the keys.
Key methods:
set(key, value) – Adds a key-value pair.
get(key) – Retrieves the value by key.
has(key) – Checks if a key exists.
delete(key) – Removes a key-value pair.
clear() – Clears all elements in the Map.
size – Returns the number of elements in the Map.
Iteration can be done using:
map.keys(), map.values(), map.entries(), or map.forEach().
Object.entries(obj) can convert an object to a Map, and Object.fromEntries(map) can do the reverse.
Set
Sets are collections of unique values (no duplicates allowed).
Key methods:
add(value) – Adds a value (does nothing if it’s already present).
delete(value) – Removes a value.
has(value) – Checks if a value exists.
clear() – Clears all elements in the Set.
size – Returns the number of elements in the Set.
Iteration can be done using:
set.keys(), set.values(), set.entries(), or set.forEach().
Differences between Map and Object:
Keys in Map can be any type, while keys in Objects are always strings (or symbols).
Map keeps insertion order, while Object doesn’t guarantee the same.
Key takeaway:
Use Map when you need to store key-value pairs where the key can be any data type, and the order of insertion is important.
Use Set when you need to maintain a collection of unique values and avoid duplicates.

WeakMap and WeakSet are powerful JavaScript data structures that handle memory management in a more efficient way compared to their regular counterparts, Map and Set. Here's a summary of their main characteristics and use cases:

WeakMap
Key Requirements: The keys of a WeakMap must always be objects, not primitive values (like numbers, strings, etc.).
Garbage Collection: A key-value pair in a WeakMap is automatically garbage collected when the key object becomes unreachable. This is because the WeakMap holds a "weak reference" to the key, meaning that the key does not prevent garbage collection if there are no other references to it.
Methods:
set(key, value): Adds a key-value pair.
get(key): Retrieves the value associated with the key.
delete(key): Removes the key-value pair.
has(key): Checks if a key exists in the map.
Limitations:
No iteration methods (e.g., keys(), values(), entries()), meaning you can't loop through the items in a WeakMap.
No size property, because it’s not possible to know how many entries remain in the WeakMap due to garbage collection.
Use Cases:
Additional Data Storage: Ideal for attaching metadata or other data to objects that belong to external code or libraries, where the data should disappear as soon as the object is no longer needed.
Memory-efficient caching: If you're caching results of expensive operations based on an object, WeakMap ensures that cached results are automatically cleared once the object is no longer in use.
WeakSet
Similar to Set: It behaves similarly to a Set, but it can only store objects (not primitive values).

Garbage Collection: Just like WeakMap, objects in a WeakSet are automatically removed when they become unreachable.

Methods:

add(value): Adds an object to the set.
has(value): Checks if an object is in the set.
delete(value): Removes an object from the set.
Limitations:

No iteration methods, so you can't iterate through the objects in a WeakSet.
No size property.
Use Cases:

Tracking Membership: Can be used to track the "membership" or status of objects, such as checking if a user has visited a site, and automatically removing them once the object is garbage collected.
Key Differences Between WeakMap/WeakSet and Their Non-Weak Counterparts:
Memory Management: In a Map or Set, an object will persist in memory as long as it is part of the collection, potentially leading to memory leaks. In contrast, objects in WeakMap and WeakSet are garbage collected when no longer in use elsewhere in the program.
No Iteration: WeakMap and WeakSet lack iteration methods like keys(), values(), or entries() because the memory state is uncertain—entries may have already been garbage collected.
Automatic Cleanup: Both WeakMap and WeakSet automatically clean up entries when the objects they hold references to are no longer reachable.
Example Use Cases:
WeakMap for User Visit Counts: You can track user visit counts, and when a user’s object is no longer in use, their count is also cleaned up without additional manual cleanup.

javascript
Copy code
let visitsCountMap = new WeakMap();

function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
In this case, when the user object is no longer in use, the visit count is also removed from memory.

WeakSet for Tracking User Visits: You can use WeakSet to keep track of users who have visited your site, without needing to manually remove them later.

javascript
Copy code
let visitedSet = new WeakSet();
visitedSet.add(john); // John visited

// Later check
visitedSet.has(john); // true
Summary:
WeakMap and WeakSet are used for more efficient memory management in JavaScript.
They allow objects to be automatically garbage collected when they are no longer in use elsewhere in the program.
They are useful for scenarios where additional data or status needs to be stored temporarily and automatically cleaned up once the object is no longer needed.

Object.keys, Object.values, and Object.entries are built-in methods in JavaScript that allow for easy iteration and manipulation of plain objects. They provide a convenient way to retrieve the keys, values, or key-value pairs from an object. Here's a breakdown of how these methods work and how you can use them effectively:

1. Object.keys(obj)
Purpose: Returns an array of the object's own enumerable property names (keys).
Syntax: Object.keys(obj)
Return: An array of strings representing the keys of the object.
Example:
javascript
Copy code
let user = {
  name: "John",
  age: 30
};

let keys = Object.keys(user); // ["name", "age"]
console.log(keys); // ["name", "age"]
2. Object.values(obj)
Purpose: Returns an array of the object's own enumerable property values.
Syntax: Object.values(obj)
Return: An array of the values of the object's properties.
Example:
javascript
Copy code
let user = {
  name: "John",
  age: 30
};

let values = Object.values(user); // ["John", 30]
console.log(values); // ["John", 30]
3. Object.entries(obj)
Purpose: Returns an array of the object's own enumerable property [key, value] pairs.
Syntax: Object.entries(obj)
Return: An array of arrays, where each inner array contains a key-value pair.
Example:
javascript
Copy code
let user = {
  name: "John",
  age: 30
};

let entries = Object.entries(user); // [["name", "John"], ["age", 30]]
console.log(entries); // [["name", "John"], ["age", 30]]
Iteration Over Objects
You can use these methods for iteration purposes, for example:

javascript
Copy code
let user = {
  name: "John",
  age: 30
};

// Iterating over values
for (let value of Object.values(user)) {
  console.log(value); // Outputs: "John", then 30
}

// Iterating over key-value pairs
for (let [key, value] of Object.entries(user)) {
  console.log(key, value); // Outputs: "name John", then "age 30"
}
Symbolic Properties
One important thing to note is that these methods ignore symbolic properties (properties that use Symbol() as a key). If you want to include symbolic keys, you can use Object.getOwnPropertySymbols() or Reflect.ownKeys():

Object.getOwnPropertySymbols(obj) returns an array of all symbolic property keys.
Reflect.ownKeys(obj) returns all property keys, including symbolic ones.
Transforming Objects
Objects don't have built-in methods like map or filter for arrays, but you can transform an object using Object.entries(), array methods, and then Object.fromEntries() to convert the transformed array back to an object.

Example: Doubling Prices in an Object Suppose you have an object representing prices and want to double them:

javascript
Copy code
let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

let doublePrices = Object.fromEntries(
  // Convert the object to an array of key/value pairs, map them, and convert back to an object
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);

console.log(doublePrices); // { banana: 2, orange: 4, meat: 8 }
This approach allows you to apply array transformations to objects, which can be powerful for many scenarios.

Summary
Object.keys: Gets an array of an object's keys.
Object.values: Gets an array of an object's values.
Object.entries: Gets an array of an object's [key, value] pairs.
Symbolic properties are ignored by these methods, but can be accessed separately.
You can transform objects using Object.entries() with array methods and then convert them back with Object.fromEntries(), providing a flexible and powerful way to manipulate object data.

This section explains the powerful concept of destructuring assignment in JavaScript, which allows you to easily unpack values from arrays or properties from objects and assign them to variables. Here's a breakdown of key concepts:

Array Destructuring:
Basic Destructuring:

Arrays can be unpacked into variables. For example:
javascript
Copy code
let arr = ["John", "Smith"];
let [firstName, surname] = arr;
alert(firstName); // John
alert(surname);  // Smith
Skipping Elements:

You can skip unwanted elements in arrays using commas.
javascript
Copy code
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
alert(title); // Consul
Rest Operator:

You can collect the remaining elements in an array into a new array using the ... (rest) operator.
javascript
Copy code
let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
Default Values:

If there are fewer elements in the array than variables on the left side, you can provide default values.
javascript
Copy code
let [firstName = "Guest", surname = "Anonymous"] = ["Julius"];
alert(surname); // Anonymous
Swapping Variables:

You can swap values between two variables using destructuring.
javascript
Copy code
let guest = "Jane";
let admin = "Pete";
[guest, admin] = [admin, guest];
alert(guest); // Pete
alert(admin); // Jane
Object Destructuring:
Basic Destructuring:

You can unpack values from objects into variables.
javascript
Copy code
let options = {title: "Menu", width: 100, height: 200};
let {title, width, height} = options;
alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
Renaming Properties:

You can assign a property to a variable with a different name using the colon :.
javascript
Copy code
let {width: w, height: h, title} = options;
alert(w);  // 100
alert(h);  // 200
Default Values:

Default values can be provided when a property is missing from the object.
javascript
Copy code
let options = {title: "Menu"};
let {width = 100, height = 200, title} = options;
alert(width);  // 100
alert(height); // 200
Rest Operator:

You can use the rest operator (...) to collect all remaining properties into a new object.
javascript
Copy code
let {title, ...rest} = options;
alert(rest.width); // 100
alert(rest.height); // 200
Nested Destructuring:

Destructuring can be nested to unpack values from deeper levels in an object.
javascript
Copy code
let options = {
  size: { width: 100, height: 200 },
  items: ["Cake", "Donut"]
};

let {
  size: { width, height },
  items: [item1, item2],
  title = "Menu"
} = options;

alert(width);   // 100
alert(height);  // 200
alert(item1);   // Cake
alert(item2);   // Donut
Smart Function Parameters:
Destructuring is also useful in function parameters to avoid handling long lists of parameters. Instead of passing parameters in a specific order, you can pass an object and destructure it inside the function.
javascript
Copy code
function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  alert(`${title} ${width} ${height}`);
  alert(items);
}

let options = { title: "My menu", items: ["Item1", "Item2"] };
showMenu(options); // My Menu 200 100
Key Points:
Arrays and objects can be destructured into individual variables.
You can rename variables, provide default values, and use the rest operator to capture remaining items.
Nested destructuring allows you to extract values from nested structures.
Default values are evaluated only when necessary, which helps with more readable and cleaner code.

The Date object in JavaScript is used to work with both the date and time. It provides multiple ways to create, manipulate, and access date/time information. Here’s a breakdown of its core features:

Creation of Date Objects:
Without arguments:

javascript
Copy code
let now = new Date(); // creates a Date object for the current date and time
With milliseconds:

javascript
Copy code
let Jan01_1970 = new Date(0); // corresponds to 01.01.1970 UTC+0
let Jan02_1970 = new Date(24 * 3600 * 1000); // 02.01.1970 UTC+0
Here, the timestamp represents milliseconds since January 1st, 1970.

From a string:

javascript
Copy code
let date = new Date("2017-01-26"); // parses string to create a Date object
This interprets the string as a date, with the time assumed to be midnight UTC.

With individual components:

javascript
Copy code
let specificDate = new Date(2011, 0, 1, 0, 0, 0, 0); // 1 Jan 2011, 00:00:00
The year and month are required. The month is 0-indexed (January = 0, December = 11).

Accessing Date Components:
You can retrieve parts of the date with the following methods:

getFullYear(): Returns the 4-digit year.
getMonth(): Returns the month (0-11).
getDate(): Returns the day of the month (1-31).
getHours(), getMinutes(), getSeconds(), getMilliseconds(): Return the corresponding components of time.
getDay(): Returns the day of the week (0 for Sunday to 6 for Saturday).
UTC versions: getUTCFullYear(), getUTCMonth(), etc. return UTC-based values.
Modifying Date Components:
You can set individual components of a Date object using methods like:

setFullYear(year, [month], [date])
setMonth(month, [date])
setHours(hour, [minute], [second], [millisecond])
For example:

javascript
Copy code
let today = new Date();
today.setHours(0); // Set the hour to midnight
today.setDate(today.getDate() + 2); // Add 2 days
Auto-correction:
If you set an invalid or out-of-range date component, JavaScript will automatically adjust the date. For example:

javascript
Copy code
let date = new Date(2013, 0, 32); // January 32nd becomes February 1st
Working with Timestamps:
Dates can be treated as timestamps (milliseconds since Jan 1st, 1970 UTC):

javascript
Copy code
let timestamp = new Date().getTime(); // Get current timestamp
let dateFromTimestamp = new Date(timestamp); // Create date from timestamp
You can also directly subtract dates, which gives the difference in milliseconds:

javascript
Copy code
let start = new Date();
// some operation
let end = new Date();
console.log(end - start); // Difference in milliseconds
Date.now():
For measuring time intervals without creating a Date object, use Date.now():

javascript
Copy code
let start = Date.now();
// some operation
let end = Date.now();
console.log(end - start); // Time difference in milliseconds
Performance Benchmarks:
You can benchmark the execution time of functions using Date-based methods, but be cautious of optimization issues. For more precise time measurements, browsers support performance.now() which provides high-resolution timestamps with microsecond precision.

Date.parse():
The Date.parse() method converts a string to a timestamp:

javascript
Copy code
let timestamp = Date.parse('2012-01-26T13:51:50.417-07:00');
let date = new Date(timestamp);
Summary:
JavaScript's Date object combines both date and time, with functions for creation, modification, and extraction of components.
It allows you to manipulate and perform arithmetic with dates (like adding days or months).
You can measure time intervals by subtracting Date objects or using Date.now().
For high-performance tasks, performance.now() or more advanced libraries may be used for microsecond precision.

The JavaScript JSON methods JSON.stringify() and JSON.parse() are crucial for converting objects to and from JSON format, which is commonly used for data transmission and storage. Here’s a quick breakdown of these methods:

JSON.stringify()
This method converts a JavaScript object or value to a JSON string.

Syntax:
javascript
Copy code
JSON.stringify(value[, replacer, space])
value: The value to be converted to a JSON string.
replacer (optional): A function or an array of keys that should be included in the JSON string. If it's a function, it allows you to modify the values before they are stringified.
space (optional): A string or number of spaces used for pretty-printing the output.
Example:
javascript
Copy code
let student = {
  name: 'John',
  age: 30,
  isAdmin: false,
  courses: ['html', 'css', 'js'],
  spouse: null
};

let json = JSON.stringify(student);
console.log(json);
This will output:

json
Copy code
{
  "name": "John",
  "age": 30,
  "isAdmin": false,
  "courses": ["html", "css", "js"],
  "spouse": null
}
Exclusions:
Function properties (methods) and undefined are excluded.
Properties with Symbol keys are excluded.
JSON.parse()
This method parses a JSON string and converts it into a JavaScript object.

Syntax:
javascript
Copy code
JSON.parse(str[, reviver])
str: The JSON string to parse.
reviver (optional): A function that can transform the parsed data. It is called for each key/value pair.
Example:
javascript
Copy code
let json = '{"name":"John", "age":30}';
let obj = JSON.parse(json);
console.log(obj); // { name: "John", age: 30 }
Customizing with toJSON and replacer
toJSON(): An object can implement the toJSON() method, which JSON.stringify() will call to transform the object into a custom format before stringifying.
Example of toJSON:
javascript
Copy code
let room = {
  number: 23,
  toJSON() {
    return this.number;
  }
};

let meetup = {
  title: "Conference",
  room
};

console.log(JSON.stringify(meetup)); // {"title":"Conference","room":23}
replacer: When using JSON.stringify(), you can provide a replacer function to control which values are included or excluded and how they are transformed.
Example of replacer:
javascript
Copy code
let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: { number: 23 }
};

let json = JSON.stringify(meetup, function(key, value) {
  if (key === "place") return undefined; // Exclude 'place'
  return value;
});

console.log(json); // {"title":"Conference","participants":[{"name":"John"},{"name":"Alice"}]}
Formatting with space
You can use the space argument to pretty-print the JSON output with indentation:

javascript
Copy code
let user = {
  name: "John",
  age: 25,
  roles: { isAdmin: false, isEditor: true }
};

let formattedJson = JSON.stringify(user, null, 2);
console.log(formattedJson);
This will output:

json
Copy code
{
  "name": "John",
  "age": 25,
  "roles": {
    "isAdmin": false,
    "isEditor": true
  }
}
Handling Circular References
If an object has circular references, JSON.stringify() will throw an error. You can manage circular references using a custom replacer function.

Parsing with reviver
You can provide a reviver function to JSON.parse() to modify the parsed values.

Example of reviver:
javascript
Copy code
let json = '{"date":"2017-11-30T12:00:00.000Z"}';

let obj = JSON.parse(json, function(key, value) {
  if (key === "date") return new Date(value);
  return value;
});

console.log(obj.date instanceof Date); // true
Summary
JSON.stringify() converts objects into JSON strings.
JSON.parse() converts JSON strings back into objects.
You can use replacer and space with JSON.stringify() for customization.
You can customize how objects are serialized with a toJSON() method.
Use a reviver function with JSON.parse() to transform values during parsing.

Chapter 6 Advanced working with fuctions

Recursion is a powerful concept in programming where a function calls itself to solve a problem. It is particularly useful for tasks that can be broken down into smaller, similar sub-tasks. Let's break down the key points from the chapter:

Key Concepts:
Recursion vs Iteration:

Iterative Solution: A solution that uses loops to repeat a task. For example, calculating the power of a number can be done using a loop that multiplies the base repeatedly.
Recursive Solution: A solution that calls the function itself with modified parameters. This reduces the problem into simpler subproblems, eventually reaching a base case that stops further calls.
Example of Power Function:

Iterative:
javascript
Copy code
function pow(x, n) {
  let result = 1;
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  return result;
}
Recursive:
javascript
Copy code
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
Execution Context and Stack:

When a function calls itself recursively, it creates a new execution context each time.
The function is paused, and its state is saved onto the execution context stack. Once the recursive call finishes, the context is popped off the stack, and the function continues execution.
This is important for understanding recursion depth. Each recursive call adds to the stack, so the depth is limited by the stack size.

Recursion Depth:

The maximum number of nested function calls (contexts) determines the recursion depth.
Recursion depth can be limited by the environment (e.g., JavaScript engines typically allow 10000 recursive calls).
While recursion can provide a simpler solution, it may use more memory than an iterative approach, as each recursive call requires its own memory space.
Recursive Traversals:

Recursion is very useful when traversing hierarchical or nested structures, such as trees or company departments.
In the company example, recursion is used to sum all salaries in a hierarchical structure of departments and sub-departments.
Recursive function to sum salaries:

javascript
Copy code
function sumSalaries(department) {
  if (Array.isArray(department)) {
    return department.reduce((prev, current) => prev + current.salary, 0);
  } else {
    let sum = 0;
    for (let subdep of Object.values(department)) {
      sum += sumSalaries(subdep); // Recursive call for subdepartments
    }
    return sum;
  }
}
Recursive Data Structures:

Linked Lists: A classic example of a recursive data structure. Each element contains a value and a reference (or "next") to the next element. This allows easy insertion and deletion at the ends but requires traversing the list to access elements by index.
Example of a linked list:

javascript
Copy code
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
Benefits and Limitations:
Benefits:
Recursion can simplify code, especially when dealing with hierarchical or recursive data structures.
It provides elegant solutions to problems that naturally break down into smaller, similar problems.
Limitations:
Recursion uses more memory because each function call adds a new execution context to the stack.
If the recursion depth is too high, it may lead to a stack overflow.
Conclusion:
Recursion is a powerful tool that can simplify code for problems involving hierarchical structures or tasks that can be broken down into similar sub-tasks. However, understanding the stack and recursion depth is important to avoid performance issues. In cases where recursion depth is a concern, it may be necessary to rewrite the recursive function using iteration.

Rest Parameters:
Purpose: Allows functions to accept an arbitrary number of arguments.
Syntax: Use the ... operator followed by a variable name (typically an array) to gather all remaining arguments passed to the function.
Where to use: In function definitions to capture excess arguments.
javascript
Copy code
function sumAll(...args) {
  return args.reduce((sum, num) => sum + num, 0);
}
Key rule: The rest parameters must always be at the end of the parameter list. Trying to place something after ...args would cause an error.

Spread Syntax:
Purpose: Expands an array (or other iterable) into individual arguments or elements.
Syntax: Use ... before the iterable in function calls or in array/object literals.
javascript
Copy code
const arr = [1, 2, 3];
const max = Math.max(...arr); // Expands arr into individual arguments
Key use cases:

Passing array elements as function arguments (e.g., Math.max).
Merging arrays or objects:
javascript
Copy code
const arr1 = [1, 2];
const arr2 = [3, 4];
const merged = [...arr1, ...arr2];
Important Distinctions:
Rest Parameters: Collects arguments into an array within the function.
Spread Syntax: Expands an array or iterable into separate arguments or elements.
Practical Example of Both:
javascript
Copy code
function showMaxAndSum(...numbers) {
  const maxNumber = Math.max(...numbers);
  const sum = numbers.reduce((acc, num) => acc + num, 0);
  console.log(`Max: ${maxNumber}, Sum: ${sum}`);
}

showMaxAndSum(3, 5, 7, 2, 8); // Max: 8, Sum: 25
In the example above:

Rest Parameters (...numbers) collect all the arguments into the numbers array.
Spread Syntax (...numbers inside Math.max()) is used to expand the array into individual arguments.
Arrow Functions & arguments:
As mentioned, arrow functions do not have their own arguments object. They inherit arguments from their parent scope.

javascript
Copy code
function example() {
  let arrowFunc = () => console.log(arguments);
  arrowFunc(5); // Logs arguments of the parent scope (if any).
}

example(1, 2, 3); // Logs: [1, 2, 3]
In contrast, a regular function would have its own arguments object.

Summary:
Rest parameters (...args) in function definitions gather excess arguments.
Spread syntax (...) expands arrays or iterables into individual elements or arguments. Both of these concepts make working with flexible numbers of arguments and array manipulation easier in JavaScript.

1. Variable Scope and Block-Level Scoping
Variables declared with let or const are block-scoped, meaning they are only accessible within the block they are defined in (i.e., within curly braces {}). This is different from var, which has function-level scope.
Example:
javascript
Copy code
{
  let message = "Hello"; 
  alert(message); // Works, prints "Hello"
}
alert(message); // Error: message is not defined
if, for, and while blocks also create isolated scopes for variables declared inside them.
2. Nested Functions and Closures
A nested function is one defined inside another function. It can access the variables of its outer function even after the outer function has finished executing.
Example:
javascript
Copy code
function makeCounter() {
  let count = 0;
  return function() {
    return count++;
  };
}

let counter = makeCounter();
alert(counter()); // 0
alert(counter()); // 1
In this example, the returned function "remembers" the count variable, even after the makeCounter function finishes execution. This is called a closure.
3. Lexical Environment
Every function and block of code has an associated Lexical Environment, which holds the variables declared within it.
A function has access to the variables in its Lexical Environment and can "look up" variables from outer environments (its parent functions or the global environment) if they are not found in the current one.
4. Closure Mechanism
JavaScript functions "remember" the Lexical Environment where they were created. This enables closures, which means that the inner function retains access to the outer variables even after the outer function has completed.
Example:
javascript
Copy code
function f() {
  let value = 123;
  return function() {
    alert(value); // value is remembered and accessible
  };
}

let g = f(); // `g` has a reference to `f`'s Lexical Environment
g(); // Alerts 123
Closures are useful because they allow for data encapsulation and persistent state across function calls.
5. Garbage Collection and Memory Management
The Lexical Environment and the variables it contains are garbage collected when they become unreachable. However, if a closure still exists that references the outer Lexical Environment, that environment will remain in memory.
Example of memory retention due to closure:
javascript
Copy code
function f() {
  let value = Math.random();
  return function() { alert(value); };
}
let g = f(); // `g` still holds a reference to `value` in `f`'s Lexical Environment
g(); // Alerts the random value
This is a key characteristic of closures: they can prevent garbage collection of outer variables, potentially leading to memory leaks if not handled correctly.
6. Real-Life Optimizations
Modern JavaScript engines, like V8 (used by Chrome and Node.js), optimize memory usage by removing unused variables from the Lexical Environment when possible. This can lead to subtle issues during debugging, where variables may not appear in the console even though they seem to be in scope.
Example:
javascript
Copy code
function f() {
  let value = Math.random();
  function g() { debugger; }
  return g;
}
let g = f();
g(); // value may not appear in console due to optimization
Summary
Scope in JavaScript is critical for understanding where and when a variable is accessible. Block-scoped variables (let, const) are confined to their respective blocks.
Closures allow inner functions to access variables from their outer functions, even after the outer function has finished executing.
The Lexical Environment is a hidden mechanism in JavaScript that keeps track of the variables and their scopes.
Functions are closures by default in JavaScript, making the language very flexible but also requiring awareness of potential memory management issues, especially in complex code or when using closures extensively.

Scope Differences:

var has function or global scope, meaning variables declared with var are accessible outside of blocks (e.g., if statements or loops).
On the other hand, let and const are block-scoped, meaning they are only available within the block they are defined in.
Redeclaration:

var allows redeclaring variables within the same scope without raising an error, which can lead to unexpected behavior.
let and const raise errors when redeclared in the same scope.
Hoisting:

var declarations are hoisted to the top of their function (or global) scope, meaning they exist even before their declaration in the code, but their value is undefined until assigned.
This can cause confusing behavior if not properly understood, especially when assignments are made after the var declaration but the variable is accessed earlier.
IIFE (Immediately Invoked Function Expression):

Due to var's lack of block-level scope, developers used to rely on IIFE to create a new scope for variables in old scripts. However, this is no longer necessary with modern JavaScript features like let and const.
Use of let and const:

In modern JavaScript, let and const are preferred over var because they provide block-scoping, and reduce issues related to hoisting and accidental redeclarations.
In summary, while var was once the main way to declare variables, the introduction of let and const provides more predictable and manageable scoping, making var less relevant for new code.

What is the Global Object?
The global object is a special object that holds variables and functions accessible from anywhere in a JavaScript environment. It provides built-in properties and functions, like alert, console, or window.innerHeight.

In a browser, the global object is called window.
In Node.js, it's called global.
globalThis is the standardized global object name, supported in all major environments, including browsers.
How to Access the Global Object
You can access the global object’s properties directly in your code:

javascript
Copy code
alert("Hello");
// Same as:
window.alert("Hello");
Global Variables and the Global Object
Variables declared using var in the global scope automatically become properties of the global object. However, variables declared with let and const do not.

javascript
Copy code
var gVar = 5;
alert(window.gVar); // 5 (it's a global property)

let gLet = 5;
alert(window.gLet); // undefined (it's not a global property)
Setting Global Properties
If you need to make a variable globally accessible, you can explicitly add it to the global object (e.g., window in browsers):

javascript
Copy code
window.currentUser = { name: "John" };
alert(currentUser.name); // John
// Or access it explicitly:
alert(window.currentUser.name); // John
Avoid Using Global Variables
Using too many global variables can lead to code that is harder to maintain and test. It’s better to use local variables and pass them as function arguments. This approach makes the code clearer and reduces the risk of conflicts.

Using Global Object for Polyfills
In cases where certain language features (like Promise) aren’t supported in older environments, you can use the global object to check for their existence and provide your own implementations (called polyfills):

javascript
Copy code
if (!window.Promise) {
  window.Promise = ... // custom implementation of Promise
}
Summary
The global object holds values that should be globally accessible in a JavaScript environment.
It’s referred to as globalThis in modern JavaScript for consistency across environments.
In browsers, variables and functions declared with var become properties of the global object (like window), but let and const do not.
It's important to minimize global variables to improve code clarity, maintainability, and avoid potential issues.
In modern JavaScript, the use of modules helps keep the global scope clean, making it easier to manage the variables and functions in your code.

Functions as Objects
Functions are objects in JavaScript, meaning they can have properties and methods just like other objects. You can assign properties to a function, and those properties will persist across calls.

Function Properties: name and length
name Property:

The name property stores the name of the function.
This property is useful when defining functions in different ways:
javascript
Copy code
function sayHi() { alert("Hi"); }
alert(sayHi.name); // sayHi
If you assign an anonymous function to a variable, the name property will be inferred from the variable's name:
javascript
Copy code
let sayHi = function() { alert("Hi"); }
alert(sayHi.name); // sayHi
The name property can also be inferred in more complex assignments:
javascript
Copy code
function f(sayHi = function() {}) { alert(sayHi.name); }
f(); // sayHi
length Property:

The length property represents the number of parameters a function expects.
Rest parameters (...args) are not counted:
javascript
Copy code
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2
This property is often used in introspection to inspect the function's parameter count.
Custom Properties on Functions
You can add custom properties to functions, making them act like objects. For example, a function can track how many times it's been called:

javascript
Copy code
function sayHi() {
  alert("Hi");
  sayHi.counter++;
}
sayHi.counter = 0;

sayHi(); // Hi
sayHi(); // Hi

alert(`Called ${sayHi.counter} times`); // Called 2 times
Difference Between Properties and Variables
A property of a function is not the same as a variable inside it. Function properties are stored directly on the function object, while variables are scoped inside the function.

Using Functions as Closures with Properties
Instead of using closures to store state, you can use function properties:

javascript
Copy code
function makeCounter() {
  function counter() {
    return counter.count++;
  }

  counter.count = 0;
  return counter;
}

let counter = makeCounter();
alert(counter()); // 0
alert(counter()); // 1
The state (count) is stored in the function property (counter.count), not in an outer lexical environment.

Named Function Expressions (NFE)
A Named Function Expression (NFE) is a function expression that has a name. While it doesn't change the function’s availability outside its context, the name helps in cases like recursion:

javascript
Copy code
let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func("Guest"); // internal recursion using the name "func"
  }
};

sayHi(); // Hello, Guest
Using the internal function name (func), you avoid the issue where the outer function's reference (sayHi) might change or be overwritten. The name (func) is only visible inside the function.

Why Use a Named Function Expression?
Recursion: You need a name for a function to call itself from within.
Avoiding Issues: If the outer function is reassigned or replaced, an internal name ensures the function can still call itself.
Summary
Functions in JavaScript are objects and can have properties.
Two useful properties for functions are:
name: The name of the function, which is inferred when not provided.
length: The number of parameters the function expects, excluding rest parameters.
Functions can also have custom properties, which is a convenient way to track or store additional data.
Named Function Expressions help with recursion and avoid issues when a function is reassigned outside its scope.
Real-world Usage
Libraries like jQuery and Lodash use this concept by defining a single global function (like $ or _) and adding helper functions as properties to it, reducing the number of global variables and preventing naming conflicts.

This approach allows you to treat functions as objects that not only perform actions but can also store additional state or functionality.

The new Function syntax in JavaScript provides a way to create a function dynamically by passing the function’s arguments and body as strings at runtime. It is rarely used but can be helpful in certain situations, such as when you need to generate a function from code received dynamically (e.g., from a server).

Syntax of new Function
The syntax for creating a function using the new Function constructor is:

javascript
Copy code
let func = new Function([arg1, arg2, ...argN], functionBody);
arg1, arg2, ..., argN are the arguments the function will accept.
functionBody is a string that contains the function’s code.
Examples
Basic Example: A function that takes two arguments (a and b) and returns their sum:

javascript
Copy code
let sum = new Function('a', 'b', 'return a + b');
alert(sum(1, 2)); // 3
No Arguments: A function with no arguments that simply alerts "Hello":

javascript
Copy code
let sayHi = new Function('alert("Hello")');
sayHi(); // Hello
Dynamic Code Execution: You can dynamically create a function from a string, which could come from an external source, like a server:

javascript
Copy code
let str = "alert('Dynamic function!')";
let func = new Function(str);
func(); // Dynamic function!
Key Differences from Regular Functions
Lexical Environment: Functions created using new Function don’t retain access to the lexical environment in which they were created. Instead, their [[Environment]] property is set to the global scope. This means that functions created this way cannot access variables in their outer scope.

For example, this will result in an error:

javascript
Copy code
function getFunc() {
  let value = "test";
  let func = new Function('alert(value)'); // value is not defined
  return func;
}

getFunc()(); // Error: value is not defined
However, in regular functions (not created with new Function), the function does have access to its enclosing lexical environment:

javascript
Copy code
function getFunc() {
  let value = "test";
  let func = function() { alert(value); };
  return func;
}

getFunc()(); // "test", from the Lexical Environment of getFunc
Why new Function Does Not Access Outer Variables
The reason for the behavior of new Function not accessing outer variables is to protect the code from issues with code minification. When JavaScript code is minified (such as during production), variable names are often shortened to reduce file size, which could cause problems if a function accessed local variables that were renamed.

If new Function had access to outer variables, it would be unable to handle minified variables correctly because it wouldn't know the new names after minification. This is why new Function works with only global variables or parameters passed explicitly to it, ensuring compatibility with minification and avoiding errors.

Using new Function Effectively
Since new Function works with global variables but not local ones, it’s generally better to pass required data explicitly as parameters, rather than relying on external variables. This avoids the issue of accessing local variables and ensures that the function’s behavior is predictable and safe, especially when the code is minified.

For example, you could pass necessary data as function arguments:

javascript
Copy code
let func = new Function('a', 'b', 'alert(a + b)');
func(1, 2); // 3
Summary
new Function is used to create a function dynamically, with arguments and body passed as strings.
The function created via new Function does not have access to the outer variables (only the global scope), which makes it safer in terms of compatibility with code minification.
This behavior encourages passing data explicitly via parameters instead of relying on the outer environment, reducing the risk of errors.

Scheduling in JavaScript: setTimeout and setInterval

In JavaScript, we can schedule functions to be executed after a delay or repeatedly at certain intervals. The two primary methods for scheduling are setTimeout and setInterval.

1. setTimeout
The setTimeout method allows you to run a function once after a specified delay (in milliseconds).

Syntax:
javascript
Copy code
let timerId = setTimeout(func | code, delay, [arg1], [arg2], ...);
func | code: The function or string of code to execute.
delay: The time in milliseconds to wait before running the function (default is 0).
arg1, arg2, ...: Arguments to pass to the function when it runs.
Example:
javascript
Copy code
function sayHi() {
  alert('Hello');
}

setTimeout(sayHi, 1000); // Executes sayHi() after 1 second
With arguments:

javascript
Copy code
function sayHi(phrase, who) {
  alert(phrase + ', ' + who);
}

setTimeout(sayHi, 1000, "Hello", "John"); // Hello, John
Passing a string of code (not recommended):

javascript
Copy code
setTimeout("alert('Hello')", 1000); // Less safe, use functions instead
Common Mistake:

javascript
Copy code
// Incorrect usage
setTimeout(sayHi(), 1000); // This executes the function immediately and passes undefined to setTimeout
Instead, pass the function without parentheses:

javascript
Copy code
setTimeout(sayHi, 1000); // Correct
Canceling setTimeout:
You can cancel a scheduled function using the clearTimeout method. setTimeout returns a timerId, which you can use to cancel the scheduled execution.

javascript
Copy code
let timerId = setTimeout(() => alert("never happens"), 1000);
clearTimeout(timerId); // The alert won't show
2. setInterval
The setInterval method allows you to run a function repeatedly at a specified interval.

Syntax:
javascript
Copy code
let timerId = setInterval(func | code, delay, [arg1], [arg2], ...);
func | code: The function or string of code to execute.
delay: The time in milliseconds between function executions.
arg1, arg2, ...: Arguments to pass to the function when it runs.
Example:
javascript
Copy code
let timerId = setInterval(() => alert('tick'), 2000); // Alerts every 2 seconds
To stop the interval, use clearInterval:

javascript
Copy code
clearInterval(timerId); // Stops the repeated alerts
Example of stopping setInterval:
javascript
Copy code
let timerId = setInterval(() => alert('tick'), 2000);

setTimeout(() => { 
  clearInterval(timerId); 
  alert('stop'); 
}, 5000); // Stops after 5 seconds
Nested setTimeout vs. setInterval
Instead of using setInterval, you can use nested setTimeout calls, which provides more control over the timing.

Example of nested setTimeout:
javascript
Copy code
let timerId = setTimeout(function tick() {
  alert('tick');
  timerId = setTimeout(tick, 2000); // Schedules the next call after the current one finishes
}, 2000);
Nested setTimeout is more flexible because it allows for dynamic control of the delay between calls (e.g., adjusting the interval based on the result of the previous execution).

Example of changing the delay dynamically:
javascript
Copy code
let delay = 5000;

let timerId = setTimeout(function request() {
  // Simulate sending a request
  if (requestFailed) {
    delay *= 2; // Increase delay if the request failed
  }

  timerId = setTimeout(request, delay); // Schedule next request
}, delay);
Garbage Collection and Timers
When using setTimeout or setInterval, the function passed is stored in memory until the timer completes. This means it is not garbage collected until it runs or is canceled. To prevent memory leaks, it’s a good practice to call clearTimeout or clearInterval once the timer is no longer needed.

Zero Delay setTimeout
A special use case of setTimeout is scheduling a function with a delay of 0 or no delay at all:

javascript
Copy code
setTimeout(() => alert("World")); // Executes after the current script finishes
alert("Hello"); // Executed first
In this case, "Hello" is displayed first, then "World" appears immediately after the current script finishes.

Zero Delay in Browsers
In modern browsers, there’s a limitation on how often nested setTimeout can run. After 5 nested calls, the interval is forced to be at least 4 milliseconds.

Example:
javascript
Copy code
let start = Date.now();
let times = [];

setTimeout(function run() {
  times.push(Date.now() - start);
  if (start + 100 < Date.now()) alert(times);
  else setTimeout(run);
});
In this case, the delays between calls will gradually increase due to the 4ms minimum delay imposed by the browser's timer system.

Summary:
setTimeout(func, delay, ...): Executes a function once after a delay.
setInterval(func, delay, ...): Executes a function repeatedly at a fixed interval.
Use clearTimeout(timerId) and clearInterval(timerId) to cancel the timers.
Nested setTimeout is more flexible than setInterval for controlling precise delays.
Zero delay (setTimeout(func, 0)) schedules the function to run as soon as possible, but after the current script.


Decorators and Forwarding
Decorators:

A decorator is a function that takes another function and alters its behavior without modifying the original function.
Example: The cachingDecorator caches the results of a slow function to avoid recalculating results for the same inputs.
Transparent Caching:

Caching avoids unnecessary recalculations by storing the result of a function call and returning the cached result if the same input is encountered.
The decorator adds caching behavior to any function, making it reusable and keeping the main code simple.
Benefits of decorators include separation of concerns, reusability, and ease of adding multiple functionalities to a function.
Handling Context (this) in Methods:

When wrapping methods in decorators, you need to handle this correctly, as a simple function call (like func(x)) can result in this being lost or undefined.
The solution is to use func.call(this, ...) or func.apply(this, ...) to ensure the correct context is maintained when calling the original function.
This ensures that methods bound to an object can still access the object's properties.
Multi-Argument Functions:

The cachingDecorator was initially designed for single-argument functions. When dealing with multiple arguments, a more flexible solution is needed.
A simple way is to use a string as the key, combining multiple arguments (e.g., min,max), which allows caching results for multi-argument functions.
call vs. apply:

Both call and apply are used to forward the context (this) and arguments to a function, but they differ in syntax.
call accepts a list of arguments, while apply accepts an array-like object.
Both can be used to ensure that the correct context and arguments are passed to the original function in a decorator.
Method Borrowing:

JavaScript's arguments object is not a real array, so methods like join that work on arrays cannot be used directly on arguments.
A technique called method borrowing is used, where you borrow an array method (e.g., [].join.call(arguments)) to achieve the desired behavior.
Function Properties and Decorators:

When a function is decorated, it may lose any properties it had, as the decorator typically returns a new function (the wrapper).
To preserve function properties, a more advanced technique like using a Proxy object is needed to wrap the function and keep its properties intact.
Summary:
Decorators are a powerful tool in JavaScript, allowing you to enhance or modify the behavior of functions without altering their original code. By using call and apply, you can ensure that the correct context (this) is passed along, and decorators can be made more flexible to handle multiple arguments and caching. Method borrowing is a technique to deal with non-array-like objects, like arguments. Function properties can be preserved using advanced techniques like Proxy.

Key Points from the Explanation:
Losing this in Callbacks:

When you pass an object method like user.sayHi directly to setTimeout, the context (this) is lost. In a callback, this refers to the global object (window in browsers), not the original object (user in this case).
javascript
Copy code
let user = { firstName: "John", sayHi() { alert(`Hello, ${this.firstName}!`); } };
setTimeout(user.sayHi, 1000); // this will alert "Hello, undefined!"
Solution 1: Wrapper Function:

Wrapping the function in another function ensures that this is preserved because the wrapper function can close over the original context (user).
javascript
Copy code
setTimeout(function() {
  user.sayHi(); // Hello, John!
}, 1000);
Solution 2: bind Method:

The bind method is a more elegant solution. It creates a new function that, when called, has this set to the specified context (user in this case).
javascript
Copy code
let sayHi = user.sayHi.bind(user); // Fixes 'this' to user
setTimeout(sayHi, 1000); // Hello, John!
Partial Functions:

The bind method can also be used to partially apply arguments. For example, creating a double function from a multiplication function by fixing the first argument:
javascript
Copy code
let double = mul.bind(null, 2); // Fix 2 as the first argument
console.log(double(3)); // 6
Convenience with bindAll:

If you have an object with multiple methods and want to bind all of them to the object, you can loop through the object's methods and apply bind to each one.
javascript
Copy code
for (let key in user) {
  if (typeof user[key] == 'function') {
    user[key] = user[key].bind(user);
  }
}
Creating Partial Functions:

You can create a partial function that applies specific arguments and this context, without modifying the function’s signature. For instance, binding only arguments without the context can be done by creating a custom partial function.
javascript
Copy code
function partial(func, ...argsBound) {
  return function(...args) {
    return func.call(this, ...argsBound, ...args);
  }
}
This custom partial function binds the initial arguments and still allows the this context to remain dynamic.

Summary:
bind() is a powerful tool to ensure the correct context for functions passed as callbacks.
It can also be used to create partial functions, making them more specific for a particular task.
Using bind() for function methods ensures that their this context remains consistent, even when passed around in asynchronous operations like setTimeout.

Arrow functions in JavaScript provide a range of advantages for specific scenarios, particularly when working with functions that need to maintain the current context (this). Here's a breakdown of the key features and differences:

Key Features of Arrow Functions:
No this Binding:

Arrow functions do not have their own this. Instead, they inherit this from the surrounding (lexical) context where they are defined.
Example:

javascript
Copy code
let group = {
  title: "Our Group",
  students: ["John", "Pete", "Alice"],
  
  showList() {
    this.students.forEach(student => {
      alert(this.title + ': ' + student); // 'this' refers to the group object
    });
  }
};
group.showList();  // Works correctly, this refers to group
In the above example, the arrow function inside forEach uses this from the showList method, ensuring it correctly refers to the group object. If we used a regular function, this would refer to undefined inside the callback.

javascript
Copy code
let group = {
  title: "Our Group",
  students: ["John", "Pete", "Alice"],
  
  showList() {
    this.students.forEach(function(student) {
      alert(this.title + ': ' + student);  // Error: Cannot read property 'title' of undefined
    });
  }
};
group.showList();  // Error
Arrow Functions Can't Be Used with new:

Since arrow functions don't have their own this, they cannot be used as constructors and cannot be called with new.
Example:

javascript
Copy code
let Person = (name) => { this.name = name; };
let john = new Person("John"); // TypeError: Person is not a constructor
No arguments Object:

Arrow functions do not have their own arguments object. They inherit arguments from the surrounding context, making them useful in cases where you need to pass the arguments without manually managing them.
Example (with arguments):

javascript
Copy code
function defer(f, ms) {
  return function() {
    setTimeout(() => f.apply(this, arguments), ms);  // `arguments` is passed correctly
  };
}

function sayHi(who) {
  alert('Hello, ' + who);
}

let sayHiDeferred = defer(sayHi, 2000);
sayHiDeferred("John");  // Hello, John after 2 seconds
Without an arrow function, you would have to manually handle the arguments and this:

javascript
Copy code
function defer(f, ms) {
  return function(...args) {
    let ctx = this;
    setTimeout(function() {
      return f.apply(ctx, args);
    }, ms);
  };
}
Arrow Functions vs. bind:

bind creates a new function where this is permanently set, but arrow functions don't bind this. Instead, they capture this from the enclosing context.
Example (with bind):

javascript
Copy code
function show() {
  alert(this.name);
}

let user = { name: "John" };
let boundShow = show.bind(user);
boundShow();  // Alerts "John"
Arrow functions, on the other hand, don't need .bind() to fix the this context because they use the this from their lexical scope.

Summary:
No this: Arrow functions don’t have their own this; they inherit this from their enclosing context.
No arguments: Arrow functions don’t have the arguments object, but they inherit it from the surrounding function.
Can't be used with new: Since they don’t have their own this, they can’t function as constructors.
Ideal for short, context-dependent functions: They are perfect for situations like callbacks, where you don’t want to explicitly manage the this context.
In essence, arrow functions are best for writing compact code that operates in the context in which it’s defined, without the need for explicit this or arguments management.


Chapter 7 object properties and configuration

Property Flags:
Each property of an object can have three special attributes (flags):

writable – Determines if the property's value can be changed.

true means the property is writable (value can be changed).
false means the property is read-only (its value cannot be changed).
enumerable – Determines whether the property shows up in loops like for...in or methods like Object.keys().

true means the property will be included in loops and listings.
false means the property will be excluded from these operations.
configurable – Determines whether the property can be deleted or its attributes (like writable, enumerable, and configurable) can be modified.

true means the property can be modified or deleted.
false means the property cannot be deleted or its flags cannot be modified.
Getting and Setting Property Descriptors:
Getting Property Descriptors: You can use Object.getOwnPropertyDescriptor(obj, propertyName) to retrieve the full property descriptor for a specific property.

javascript
Copy code
let user = { name: "John" };
let descriptor = Object.getOwnPropertyDescriptor(user, "name");
console.log(descriptor);
// Output: { value: "John", writable: true, enumerable: true, configurable: true }
Setting Property Descriptors: You can use Object.defineProperty(obj, propertyName, descriptor) to modify or define a property with specific flags.

javascript
Copy code
Object.defineProperty(user, "name", { writable: false });
Example Effects of Property Flags:
Non-writable: If a property is marked as writable: false, attempts to change its value will result in an error in strict mode.

javascript
Copy code
Object.defineProperty(user, "name", { writable: false });
user.name = "Pete"; // Error in strict mode: Cannot assign to read-only property 'name'
Non-enumerable: If a property is marked as enumerable: false, it will not appear in for...in loops or Object.keys() calls.

javascript
Copy code
Object.defineProperty(user, "toString", { enumerable: false });
for (let key in user) {
  console.log(key); // Only "name" will be logged
}
Non-configurable: A property with configurable: false cannot be deleted or have its descriptors changed. This is useful for preventing accidental modification of critical properties.

javascript
Copy code
Object.defineProperty(user, "name", { configurable: false });
delete user.name; // Error: Cannot delete property 'name'
Object.defineProperties and Object.getOwnPropertyDescriptors:
Object.defineProperties: This method allows you to define multiple properties at once.

javascript
Copy code
Object.defineProperties(user, {
  name: { value: "John", writable: false },
  surname: { value: "Smith", writable: false }
});
Object.getOwnPropertyDescriptors: This method returns all descriptors for all properties of an object, including symbolic and non-enumerable ones.

javascript
Copy code
let descriptors = Object.getOwnPropertyDescriptors(user);
Sealing and Freezing Objects:
These methods work at the object level, limiting what can be done with the object as a whole:

Object.preventExtensions(obj): Prevents new properties from being added to the object.
Object.seal(obj): Prevents adding or removing properties, and sets configurable: false for all existing properties.
Object.freeze(obj): Prevents adding, removing, or changing properties, and sets configurable: false and writable: false for all existing properties.
Methods to Check Object Status:
Object.isExtensible(obj): Returns false if new properties cannot be added to the object.
Object.isSealed(obj): Returns true if properties can't be added or removed, and all properties are configurable: false.
Object.isFrozen(obj): Returns true if no properties can be added, removed, or changed, and all properties are configurable: false and writable: false.
Use Cases and Considerations:
Property descriptors are rarely used in everyday coding, but they provide fine-grained control over how properties behave, especially in cases where immutability, data encapsulation, or property protection is required.
Sealing and freezing are used in scenarios where you need to protect objects from accidental or intentional modification.
DefineProperty and DefineProperties are helpful in defining or adjusting object behavior at runtime.
These tools can be very powerful for controlling object properties and creating robust, well-encapsulated code.

data properties and accessor properties.

1. Data Properties
Data properties are the standard key-value pairs we've worked with until now. They have a value and optional flags like writable, enumerable, and configurable.

2. Accessor Properties
Accessor properties are a special kind of property that don't directly store a value. Instead, they are backed by a getter and/or setter method, which provide a way to control how values are accessed or modified. From the outside, they appear as regular properties, but behind the scenes, functions are invoked when the property is read or written to.

Syntax:
javascript
Copy code
let obj = {
  get propName() {
    // getter function, executed when obj.propName is accessed
  },
  set propName(value) {
    // setter function, executed when obj.propName is assigned a value
  }
};
Examples of Getters and Setters:
Let’s look at an example where we have a user object with name and surname, and we want to add a fullName property:

Defining a Getter:
javascript
Copy code
let user = {
  name: "John",
  surname: "Smith",
  
  get fullName() {
    return `${this.name} ${this.surname}`;
  }
};

console.log(user.fullName); // Output: "John Smith"
Here, fullName appears as a regular property, but it runs the getter function behind the scenes when accessed.

Defining a Setter:
If we want to be able to set the fullName, we can add a setter:

javascript
Copy code
let user = {
  name: "John",
  surname: "Smith",
  
  get fullName() {
    return `${this.name} ${this.surname}`;
  },
  
  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  }
};

user.fullName = "Alice Cooper";  // Setter is called
console.log(user.name);          // Output: "Alice"
console.log(user.surname);       // Output: "Cooper"
Here, we used the setter to split the fullName into name and surname when the property is set.

Accessor Descriptors:
When you use Object.defineProperty() to define an accessor property, you don't specify value or writable, but instead provide get and/or set functions.

javascript
Copy code
let user = {
  name: "John",
  surname: "Smith"
};

Object.defineProperty(user, "fullName", {
  get() {
    return `${this.name} ${this.surname}`;
  },
  set(value) {
    [this.name, this.surname] = value.split(" ");
  }
});

console.log(user.fullName); // Output: "John Smith"
user.fullName = "Alice Cooper";
console.log(user.name);     // Output: "Alice"
console.log(user.surname);  // Output: "Cooper"
Important Considerations:
Getters and Setters cannot be both data properties (with value) and accessor properties (with get and set) at the same time. If you try to combine value and get in the same descriptor, it will throw an error:

javascript
Copy code
// Error: Invalid property descriptor.
Object.defineProperty({}, 'prop', {
  get() {
    return 1;
  },
  value: 2
});
Getters and Setters provide a way to encapsulate the logic of getting and setting a value. You can add validation or computation logic inside these functions. For example, you can check the length of a name before setting it:

javascript
Copy code
let user = {
  _name: "",

  get name() {
    return this._name;
  },

  set name(value) {
    if (value.length < 4) {
      alert("Name is too short, need at least 4 characters");
      return;
    }
    this._name = value;
  }
};

user.name = "Pete";   // Works fine
alert(user.name);     // "Pete"

user.name = "";       // Alert: "Name is too short"
Here, the setter ensures that the name cannot be set to a value shorter than 4 characters.

Compatibility Example:
Accessors are especially useful when you want to add new behavior (like calculated values) to existing objects without breaking backwards compatibility. For instance, suppose we initially had a User object with a name and age:

javascript
Copy code
function User(name, age) {
  this.name = name;
  this.age = age;
}

let john = new User("John", 25);
console.log(john.age); // Output: 25
Later, we decide to replace age with birthday, but we still want to support the old age property:

javascript
Copy code
function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;

  Object.defineProperty(this, "age", {
    get() {
      let todayYear = new Date().getFullYear();
      return todayYear - this.birthday.getFullYear();
    }
  });
}

let john = new User("John", new Date(1992, 6, 1));

console.log(john.birthday); // Output: the birthday date
console.log(john.age);      // Output: 32 (calculated based on the birthday)
In this case, we use a getter for age to calculate the age dynamically based on the birthday, without needing to change other parts of the code that depend on the age property.

Summary:
Getter: A function executed when a property is accessed.
Setter: A function executed when a property is set.
Accessor Descriptors: Used with Object.defineProperty to define getter and setter functions.
Use cases:
For computed or derived values (e.g., age from birthday).
For validation when setting values (e.g., checking the length of a name).
To maintain compatibility when refactoring code.


Chapter 8 Prototypes, inheritance

Key Concepts:
[[Prototype]]:

Every JavaScript object has an internal property called [[Prototype]], which references another object or null. This forms the basis of prototypal inheritance.
When you try to access a property that doesn't exist in an object, JavaScript looks for it in the object’s prototype chain (i.e., the prototype object).
Setting Prototypes:

You can set the prototype of an object using the special __proto__ property.
Example:
javascript
Copy code
let animal = { eats: true };
let rabbit = { jumps: true };
rabbit.__proto__ = animal;  // Set animal as prototype of rabbit
console.log(rabbit.eats);  // true, inherited from animal
Inheritance Chain:

Prototypal inheritance allows multiple levels of inheritance. For example, rabbit can inherit from animal, and longEar can inherit from rabbit.
Example:
javascript
Copy code
let animal = { eats: true, walk() { console.log("Animal walk"); }};
let rabbit = { jumps: true, __proto__: animal };
let longEar = { earLength: 10, __proto__: rabbit };
longEar.walk();  // Inherited walk() method from animal
Method Inheritance:

Methods defined on a prototype are inherited by objects. If the object doesn't have a method, JavaScript looks for it in the prototype chain.
Example:
javascript
Copy code
let animal = { walk() { console.log("Animal walk"); }};
let rabbit = { __proto__: animal };
rabbit.walk();  // Inherited from animal
Overriding Methods:

Objects can override methods inherited from the prototype.
Example:
javascript
Copy code
let animal = { walk() { console.log("Animal walk"); }};
let rabbit = { walk() { console.log("Rabbit bounce"); }, __proto__: animal };
rabbit.walk();  // "Rabbit bounce" (overridden)
The this Keyword:

Regardless of where a method is located (on the object or its prototype), the this keyword always refers to the object that calls the method. It doesn’t change based on where the method is found.
for...in Loop:

The for...in loop iterates over both own properties and inherited properties of an object. To exclude inherited properties, you can use the hasOwnProperty() method.
Example:
javascript
Copy code
let animal = { eats: true };
let rabbit = { jumps: true, __proto__: animal };
for (let prop in rabbit) {
  if (rabbit.hasOwnProperty(prop)) {
    console.log(prop);  // Only "jumps"
  }
}
Methods and Properties in Prototypes:

Methods like hasOwnProperty() are inherited from Object.prototype, but since they are non-enumerable, they do not appear in for...in loops.
Other methods like Object.keys() or Object.values() only operate on the object's own properties, ignoring the prototype chain.
Summary:
Prototypal inheritance allows JavaScript objects to inherit properties and methods from other objects.
The __proto__ property is used to set the prototype of an object, but newer methods like Object.getPrototypeOf() are recommended.
The this keyword in a method always refers to the object that calls the method, even if the method is inherited.
The for...in loop iterates over both own and inherited properties, whereas methods like Object.keys() only consider the object's own properties.
Prototypal inheritance makes JavaScript flexible, allowing objects to extend other objects easily without the need for classes or duplicating code.

Key Concepts:
F.prototype and [[Prototype]]:

Every constructor function F in JavaScript has a prototype property, which is used to set the [[Prototype]] of objects created with the new F() syntax.
When a new object is created using new F(), JavaScript assigns the value of F.prototype to the object's [[Prototype]]. This means that the new object will inherit properties and methods from F.prototype.
Example:

javascript
Copy code
let animal = { eats: true };

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit("White Rabbit");
console.log(rabbit.eats);  // true, inherited from Rabbit.prototype (which is animal)
Setting F.prototype:

The F.prototype property is only used during object creation with new F(). If you change F.prototype after creating an object, it doesn’t affect the existing objects, but it will affect new objects created after the change.
Example:

javascript
Copy code
function Rabbit(name) {
  this.name = name;
}

let rabbit1 = new Rabbit("White Rabbit");

Rabbit.prototype = { jumps: true };  // Change the prototype

let rabbit2 = new Rabbit("Black Rabbit");

console.log(rabbit1.jumps);  // undefined, rabbit1 still inherits from the old prototype
console.log(rabbit2.jumps);  // true, rabbit2 inherits from the new prototype
The Default F.prototype:

By default, every function in JavaScript has a prototype property, and that property is an object with a single constructor property pointing back to the function itself. This means every object created via the constructor function will have access to the constructor property.
Example:

javascript
Copy code
function Rabbit() {}
console.log(Rabbit.prototype.constructor === Rabbit);  // true
Using constructor to Create New Objects:

You can use the constructor property to create new objects of the same type as an existing one, especially when you're unsure of the exact constructor used to create an object.
Example:

javascript
Copy code
function Rabbit(name) {
  this.name = name;
}

let rabbit1 = new Rabbit("White Rabbit");
let rabbit2 = new rabbit1.constructor("Black Rabbit");

console.log(rabbit2.name);  // "Black Rabbit"
Issues with Overwriting F.prototype:

If you overwrite F.prototype entirely, you may lose the reference to the constructor property, which can break functionality that depends on it.
Example:

javascript
Copy code
function Rabbit() {}
Rabbit.prototype = { jumps: true };

let rabbit = new Rabbit();
console.log(rabbit.constructor === Rabbit);  // false
To preserve the constructor property, you can either add to the existing prototype or manually restore the constructor property:
Example:

javascript
Copy code
// Add to the prototype
function Rabbit() {}
Rabbit.prototype.jumps = true;
console.log(rabbit.constructor === Rabbit);  // true

// Manually restore the constructor property
Rabbit.prototype = {
  jumps: true,
  constructor: Rabbit
};
console.log(rabbit.constructor === Rabbit);  // true
Summary:
F.prototype is a property of constructor functions and is used to set the [[Prototype]] of objects created using new F().
When you create a new object using new F(), its [[Prototype]] is set to F.prototype.
The constructor property is automatically set on the F.prototype object and points back to the constructor function.
You can modify F.prototype after objects are created, but it will only affect new objects, not existing ones.
Be cautious when overwriting F.prototype to avoid losing the constructor property, which is important for creating new instances.
In practice, this system of prototype chaining allows objects to inherit methods and properties from other objects, forming a fundamental part of JavaScript's object-oriented programming capabilities.

Key Concepts:
Prototypes of Built-in Objects:

In JavaScript, every built-in object, such as Object, Array, Date, Function, etc., has a prototype property that contains methods available to all instances created with that constructor.
For example, when you create an object using {} or new Object(), the object's [[Prototype]] is set to Object.prototype. This is why all objects inherit methods like toString() from Object.prototype.
Example:

javascript
Copy code
let obj = {};
alert(obj);  // Output: [object Object]
alert(obj.__proto__ === Object.prototype);  // true
alert(obj.toString === obj.__proto__.toString);  // true
Prototype Chain:

Objects in JavaScript have a prototype chain. For example, an array created with [1, 2, 3] inherits from Array.prototype, and Array.prototype itself inherits from Object.prototype.
Every object can trace its prototype chain back to Object.prototype, which is at the top, with null as its prototype.
Example:

javascript
Copy code
let arr = [1, 2, 3];
alert(arr.__proto__ === Array.prototype);  // true
alert(arr.__proto__.__proto__ === Object.prototype);  // true
alert(arr.__proto__.__proto__.__proto__);  // null
Methods in Prototypes:

Built-in objects like arrays, strings, and functions have their own methods in their respective prototypes.
For instance, Array.prototype has its own toString() method that lists array elements, which takes precedence over Object.prototype.toString() when called on arrays.
Example:

javascript
Copy code
let arr = [1, 2, 3];
alert(arr.toString());  // Output: "1,2,3"
Primitives and Wrapper Objects:

JavaScript primitives like strings, numbers, and booleans are not objects, but they can have methods accessed via temporary wrapper objects (String, Number, Boolean).
For example, when you call a string method like "hello".toUpperCase(), JavaScript internally creates a String object to provide access to String.prototype methods.
However, null and undefined do not have wrapper objects, so they don't have access to methods or prototypes.

Modifying Native Prototypes:

Modifying the native prototypes (such as String.prototype or Array.prototype) can introduce new methods to all instances of that type. While this is possible, it is generally discouraged due to the risk of conflicts and overwriting existing methods, especially when using third-party libraries.
Polyfilling is an exception, where you add missing methods to prototypes for browsers or environments that don't support them.
Example (adding a new method to String.prototype):

javascript
Copy code
String.prototype.show = function() {
  alert(this);
};

"BOOM!".show();  // Output: BOOM!
Polyfilling:

Polyfilling is the process of providing a fallback for a method that may not be available in all JavaScript engines. For example, the String.prototype.repeat() method was introduced in ECMAScript 6, and for older engines, we can polyfill it as follows:
Example:

javascript
Copy code
if (!String.prototype.repeat) {
  String.prototype.repeat = function(n) {
    return new Array(n + 1).join(this);
  };
}

alert("La".repeat(3));  // Output: "LaLaLa"
Borrowing Methods from Prototypes:

You can borrow methods from one object's prototype and use them in another. For instance, if you have an object that behaves like an array, you can borrow the Array.prototype.join method.
Example:

javascript
Copy code
let obj = {
  0: "Hello",
  1: "world!",
  length: 2,
};

obj.join = Array.prototype.join;
alert(obj.join(','));  // Output: "Hello,world!"
Limitations of Borrowing:

While borrowing methods is flexible, it's limited in that an object can only inherit from one prototype at a time. This makes it impossible to inherit methods from multiple prototypes unless you explicitly copy methods over.
Summary:
Built-in objects like Object, Array, Date, and others have their methods stored in their respective prototypes, such as Object.prototype, Array.prototype, etc.
Primitives (like strings, numbers, and booleans) also have prototypes via temporary wrapper objects (String.prototype, Number.prototype, Boolean.prototype).
Modifying native prototypes is possible but discouraged due to risks like conflicts and overwriting existing methods. The only widely accepted reason for modifying native prototypes is for polyfilling.
Borrowing methods from prototypes is a useful technique when you want to use a method from one object on another object that isn't directly inheriting from it.

Modern Methods for Managing Prototypes:
Object.getPrototypeOf(obj): Returns the prototype of the object obj (equivalent to reading obj.__proto__).
Object.setPrototypeOf(obj, proto): Sets the prototype of the object obj to proto (equivalent to writing obj.__proto__ = proto).
Object.create(proto[, descriptors]): Creates an object with the specified prototype (proto) and optional descriptors. This method can be used to create objects without any inherited properties, effectively isolating them from the default behavior of regular objects.
Prototype-less Objects:
Object.create(null) or { __proto__: null }: Creates an object with no prototype, meaning it doesn't inherit any methods like toString or properties from Object.prototype. These objects are useful for cases like creating simple dictionaries where user input may be used as keys. This avoids unexpected side effects from inherited properties such as __proto__.
Why __proto__ Is Deprecated:
The __proto__ property is deprecated for direct use in JavaScript because it can lead to performance issues. Modifying an object’s prototype after it’s created can slow down operations, as JavaScript engines optimize objects based on their prototypes.
Instead of __proto__, the modern methods (Object.getPrototypeOf and Object.setPrototypeOf) are recommended. However, __proto__ is still allowed in object literals ({ __proto__: ... }).
Special Cases with __proto__:
Using __proto__ as a key: When a user provides __proto__ as a key in a plain object, the assignment may be ignored because __proto__ is a special property. To avoid this problem, you can use Object.create(null) to create an object that doesn't inherit from Object.prototype and has no special handling of the __proto__ key.
Example of a Prototype-less Object:
javascript
Copy code
let obj = Object.create(null);
let key = prompt("What's the key?", "__proto__");
obj[key] = "some value";
alert(obj[key]); // "some value"
Cloning Objects with Prototypes:
Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)): This creates a shallow copy of the object obj, maintaining its prototype and property descriptors (such as enumerable, writable, configurable).
Summary:
To create objects with specific prototypes, use:

{ __proto__: ... } for object literals.
Object.create(proto[, descriptors]) for more flexible object creation.
Use modern methods like Object.getPrototypeOf and Object.setPrototypeOf to interact with prototypes instead of the deprecated __proto__ getter and setter.

Avoid using __proto__ as a key in object properties, or use Object.create(null) to avoid potential issues when treating objects as associative arrays or dictionaries

Chapter 9 Classes

 JavaScript, classes provide a more structured way to define object-oriented constructs, making it easier to create objects with shared behavior. Here’s a breakdown of key features and concepts from the class syntax:

Basic Class Syntax
A class is defined using the class keyword. It can contain a constructor and methods. The constructor is called when you create a new instance of the class using the new keyword. Here’s the basic syntax:

javascript
Copy code
class MyClass {
  constructor() {
    // Initialization code
  }
  
  method1() {
    // Method 1 code
  }

  method2() {
    // Method 2 code
  }
}
Example: Creating and Using a Class
Let’s create a simple User class that stores a user's name and has a method to greet the user:

javascript
Copy code
class User {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    alert(this.name);
  }
}

let user = new User("John");
user.sayHi();  // Alerts: John
Understanding How Classes Work
Constructor: This method is automatically invoked when a new object is created using new. It initializes the object's state.
Methods: Methods defined in the class body are automatically added to the class’s prototype. For example, sayHi is stored in User.prototype.
this: Inside the class methods, this refers to the instance of the object.
Class vs Constructor Functions
Classes are a more modern way to define constructor functions. Under the hood, classes are essentially special functions:

javascript
Copy code
class User {
  constructor(name) {
    this.name = name;
  }
}

alert(typeof User); // "function"
This demonstrates that User is still a function, but with some additional features that make it easier to work with, like automatic strict mode and more syntactic convenience.

Important Features of Classes
No commas between methods: In a class, there is no need to separate methods with commas (unlike in object literals).
Methods are non-enumerable: Methods defined in the class are not enumerated by a for...in loop. This avoids accidental enumeration of methods.
Strict mode: Classes automatically use strict mode, which restricts certain actions (e.g., defining undeclared variables).
Class Fields: These allow defining properties directly in the class body (without needing to initialize them in the constructor).
javascript
Copy code
class User {
  name = "John";

  sayHi() {
    alert(`Hello, ${this.name}`);
  }
}

let user = new User();
user.sayHi();  // Alerts: Hello, John
Class Expression
Classes can be defined inside expressions (just like functions). This allows classes to be dynamically created and used as values:

javascript
Copy code
let User = class {
  sayHi() {
    alert("Hello");
  }
};

new User().sayHi();  // Alerts: Hello
Getter and Setter Methods
Classes can define getter and setter methods, which allow controlled access to an object's properties:

javascript
Copy code
class User {
  constructor(name) {
    this.name = name;
  }

  get name() {
    return this._name;
  }

  set name(value) {
    if (value.length < 4) {
      alert("Name is too short.");
      return;
    }
    this._name = value;
  }
}

let user = new User("John");
alert(user.name);  // Alerts: John

user = new User("");  // Alerts: Name is too short.
Binding Methods with Class Fields
One problem in JavaScript is that when object methods are passed around, they can lose their context (this). Class fields can help solve this by using arrow functions that automatically bind this to the object:

javascript
Copy code
class Button {
  constructor(value) {
    this.value = value;
  }

  click = () => {
    alert(this.value);
  }
}

let button = new Button("hello");
setTimeout(button.click, 1000);  // Alerts: hello
Summary
Classes are a syntactic sugar over constructor functions that make working with objects easier.
Classes can contain constructors, methods, getters/setters, and class fields.
Class expressions allow classes to be dynamically created.
Using class fields provides an elegant way to bind methods to their objects.
JavaScript classes make it easier to write object-oriented code while ensuring consistent behavior and context for methods. As we dive deeper into inheritance and other class features, you’ll see how powerful and flexible classes can be in JavaScript.

This is a thorough explanation of class inheritance in JavaScript, including how the extends keyword works, how to override methods, the usage of the super keyword, and how the class constructors function. Here's a breakdown of the key concepts:

Class Inheritance and the extends Keyword:

The extends keyword allows one class to inherit properties and methods from another class. For example, class Rabbit extends Animal means that Rabbit will inherit from Animal.
This gives the child class (Rabbit) access to the methods and properties of the parent class (Animal).
Overriding Methods:

When a method is defined in a subclass (e.g., Rabbit), it overrides the parent class method (e.g., Animal).
If you want to call the parent class method within the child class, you use the super keyword. For instance, calling super.stop() within a method in Rabbit will invoke the stop method from Animal.
Calling the Parent Constructor with super():

If a subclass has a constructor, it must call the parent constructor using super() before accessing this. This ensures the object is properly initialized by the parent class before the child class adds its own properties.
Arrow Functions and super:

Arrow functions do not have their own super keyword or this. Instead, they inherit super from the surrounding context, making them suitable for situations like calling super inside an arrow function.
A regular function (non-arrow) would cause an error when accessing super if used incorrectly.
Special Internal Property [[HomeObject]]:

Every method in a class has an internal property [[HomeObject]] that refers to the class or object it was defined in. This ensures that when calling super, it correctly refers to the prototype chain of the current object.
This behavior can be confusing when methods are copied between objects because [[HomeObject]] is preserved, potentially leading to unexpected results.
Class Fields and Constructor Order:

When overriding class fields, JavaScript initializes fields in a specific order: fields are initialized before the constructor is called in the base class, which can lead to subtle bugs if the parent constructor depends on the overridden fields.
Method Copying and super:

If a method is copied between objects, its [[HomeObject]] property (the object it was originally created in) can cause problems with super, as the copied method will always try to call its parent method from the original [[HomeObject]].
This deep dive into inheritance in JavaScript explains both how to use class inheritance effectively and the underlying mechanics, such as [[HomeObject]] and the super keyword. It's a great guide for understanding how inheritance works in JavaScript and can help prevent common pitfalls when extending classes or working with method overrides.

Static properties and methods in JavaScript are used when the functionality or data belongs to the class itself, rather than to instances of the class. They are declared with the static keyword and can be accessed using the class name, not an instance.

Key Points:
Static Methods:

Belong to the class itself and are not tied to instances.
Can be used for utility functions, such as comparisons or factory methods.
Can be called on the class directly, like Class.method().
Example:

javascript
Copy code
class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }

  static compare(articleA, articleB) {
    return articleA.date - articleB.date;
  }
}

const articles = [
  new Article("HTML", new Date(2019, 1, 1)),
  new Article("CSS", new Date(2019, 0, 1)),
  new Article("JavaScript", new Date(2019, 11, 1))
];

articles.sort(Article.compare); // Uses the static method for sorting
Static Properties:

Store class-level data that is not tied to any instance.
Can be accessed with Class.property.
Example:

javascript
Copy code
class Article {
  static publisher = "Ilya Kantor";
}

console.log(Article.publisher); // Outputs: "Ilya Kantor"
Inheritance:

Static methods and properties are inherited by subclasses, just like regular methods, but they belong to the class itself, not the instances.
When a class extends another, the subclass can access the static properties and methods of the parent class.
Example:

javascript
Copy code
class Animal {
  static planet = "Earth";

  static compare(animalA, animalB) {
    return animalA.speed - animalB.speed;
  }
}

class Rabbit extends Animal {}

console.log(Rabbit.planet); // Outputs: "Earth"
Syntax Recap:
Static property:

javascript
Copy code
class MyClass {
  static property = value;
}
Static method:

javascript
Copy code
class MyClass {
  static method() {
    // method logic
  }
}
Inheritance in Static Methods:
Static methods and properties are inherited through the class itself. For example, Rabbit inherits from Animal, so Rabbit can access Animal's static methods and properties.

Conclusion:
Static methods and properties are useful when you need to perform operations or store data that is related to the class itself rather than an instance. They help in situations like comparisons, creating factory methods, or accessing shared data.

Extending built-in classes in JavaScript, such as Array, Map, Set, and others, is a powerful feature that allows you to add custom behavior to native objects. However, there are some important nuances to understand when doing this, especially when dealing with built-in methods like map, filter, and others.

Extending Built-In Classes
You can create a subclass of a built-in class, such as Array, and add custom methods or properties. For example, if you want to add an isEmpty method to the Array class, you can create a subclass:

Example: Extending Array with a custom method:

javascript
Copy code
class PowerArray extends Array {
  isEmpty() {
    return this.length === 0;
  }
}

let arr = new PowerArray(1, 2, 5, 10, 50);
alert(arr.isEmpty()); // false

let filteredArr = arr.filter(item => item >= 10);
alert(filteredArr); // [10, 50]
alert(filteredArr.isEmpty()); // false
Here, PowerArray extends the native Array class, and we've added an isEmpty method. When you call .filter(), it returns a new array of the same type (PowerArray), so you can still call the isEmpty method on the filtered result.

constructor Property and Method Inheritance
The key point here is that built-in methods like filter, map, and others return a new object that is an instance of the constructor associated with the calling array. So, when arr.filter() is called, it internally uses arr.constructor (which points to PowerArray) to create the new array.

Example of constructor property:

javascript
Copy code
let arr = new PowerArray(1, 2, 5, 10, 50);
console.log(arr.constructor); // PowerArray
let filteredArr = arr.filter(item => item >= 10);
console.log(filteredArr.constructor); // PowerArray
This means that the extended functionality of PowerArray is preserved through the new array that is returned by filter.

Customizing the Behavior with Symbol.species
You can control what constructor is used when methods like filter, map, slice, etc., return new instances by defining a static get [Symbol.species](). This allows you to specify whether the returned objects should be of the same class or another class, like the regular Array.

Example: Using Symbol.species to change the constructor:

javascript
Copy code
class PowerArray extends Array {
  isEmpty() {
    return this.length === 0;
  }

  static get [Symbol.species]() {
    return Array;
  }
}

let arr = new PowerArray(1, 2, 5, 10, 50);
alert(arr.isEmpty()); // false

// filter creates new array using arr.constructor[Symbol.species] as constructor
let filteredArr = arr.filter(item => item >= 10);
alert(filteredArr.constructor); // Array
alert(filteredArr.isEmpty()); // Error: filteredArr.isEmpty is not a function
In this example, Symbol.species returns Array, so even though arr is an instance of PowerArray, the filter method returns a regular Array. As a result, the new array doesn't have the isEmpty method that was added in PowerArray.

Other Collections (Map, Set, etc.)
Just like Array, other collections such as Map and Set also respect the Symbol.species property, so you can control whether the methods like map or filter return instances of the extended class or regular Map/Set objects.

Static Inheritance in Built-In Classes
A unique aspect of JavaScript’s built-in classes is that they do not inherit static methods from their parent classes. For example, while Array and Date both inherit from Object, their static methods (such as Array.isArray or Date.now) are not inherited. This means you cannot access static methods like Object.keys from Array or Date.

Example:

javascript
Copy code
console.log(Array.isArray([])); // true
console.log(Date.now()); // Current timestamp
console.log(Array.keys); // undefined
console.log(Date.keys); // undefined
In the above example, Array and Date do not have their own versions of keys, because they do not inherit static methods from Object.

Summary
Extending built-in classes allows you to add custom methods and properties to objects like Array, Map, and Set.
Built-in methods like map, filter, etc., will return objects of the same type as the calling object, preserving any additional functionality.
The Symbol.species static getter allows you to customize the constructor used by built-in methods when they return new objects.
Static inheritance in built-in classes is not the same as regular inheritance. Built-in classes like Array and Date do not inherit static methods from their parent class, Object.

Basics of instanceof
The syntax for instanceof is:

javascript
Copy code
obj instanceof Class
It returns true if obj is an instance of Class, or if obj is an instance of a subclass that inherits from Class. Otherwise, it returns false.

Example with instanceof
javascript
Copy code
class Rabbit {}
let rabbit = new Rabbit();

// Check if 'rabbit' is an instance of Rabbit
alert(rabbit instanceof Rabbit); // true
You can also use instanceof with constructor functions:

javascript
Copy code
function Rabbit() {}
alert(new Rabbit() instanceof Rabbit); // true
Works with Built-in Classes
The instanceof operator works with built-in JavaScript classes like Array, Object, etc.

javascript
Copy code
let arr = [1, 2, 3];
alert(arr instanceof Array); // true
alert(arr instanceof Object); // true
Prototype Chain
instanceof works by checking the prototype chain. It compares the prototype of the class with the __proto__ chain of the object:

obj.__proto__ === Class.prototype
obj.__proto__.__proto__ === Class.prototype
And so on...
For example:

javascript
Copy code
class Animal {}
class Rabbit extends Animal {}

let rabbit = new Rabbit();
alert(rabbit instanceof Animal); // true
In this case, rabbit is an instance of Rabbit, but since Rabbit extends Animal, rabbit instanceof Animal is true. The check looks for Rabbit.prototype in the rabbit.__proto__ chain.

Customizing instanceof with Symbol.hasInstance
You can customize how instanceof works by defining a static method Symbol.hasInstance in your class. This method is called when instanceof is used on the class, and it should return a boolean indicating if the object is considered an instance.

javascript
Copy code
class Animal {
  static [Symbol.hasInstance](obj) {
    return obj.canEat === true;
  }
}

let obj = { canEat: true };
alert(obj instanceof Animal); // true
In this case, the Symbol.hasInstance method checks if the object has the canEat property, and if so, it returns true, making obj instanceof Animal evaluate to true.

Changing the Prototype and instanceof
If the prototype of a class is changed after the object is created, the instanceof check can behave differently:

javascript
Copy code
function Rabbit() {}
let rabbit = new Rabbit();

// Change the prototype of Rabbit
Rabbit.prototype = {};

alert(rabbit instanceof Rabbit); // false
Even though rabbit was initially an instance of Rabbit, after changing Rabbit.prototype, it no longer satisfies the prototype chain for Rabbit, and instanceof returns false.

isPrototypeOf Method
The isPrototypeOf method can also be used to check if an object is part of the prototype chain of another object:

javascript
Copy code
class Animal {}
class Rabbit extends Animal {}

let rabbit = new Rabbit();
alert(Animal.prototype.isPrototypeOf(rabbit)); // true
This is equivalent to rabbit instanceof Animal.

Object.prototype.toString and Customizing Types
The Object.prototype.toString method is a more advanced form of type-checking. It can be used as an alternative to instanceof to check the type of an object, including built-in types and custom objects.

javascript
Copy code
let arr = [];
let objToString = Object.prototype.toString;
alert(objToString.call(arr)); // [object Array]
Symbol.toStringTag
The Symbol.toStringTag property allows customizing the string returned by Object.prototype.toString. It is often used in built-in JavaScript objects and can be customized for user-defined objects as well.

javascript
Copy code
let user = {
  [Symbol.toStringTag]: "User"
};
alert(Object.prototype.toString.call(user)); // [object User]
For built-in objects, such as window and XMLHttpRequest, this tag can also be used to customize their string representation:

javascript
Copy code
alert(Object.prototype.toString.call(window)); // [object Window]
alert(Object.prototype.toString.call(new XMLHttpRequest())); // [object XMLHttpRequest]
Summary of Type-Checking Methods
typeof: Used for checking primitive types. Returns a string (e.g., "number", "boolean", "object", etc.).
{}.toString.call: More advanced than typeof, it works for both primitives and built-in objects and can be customized using Symbol.toStringTag.
instanceof: Checks if an object is an instance of a class, considering inheritance. Returns true or false.
isPrototypeOf: Checks if an object is part of another object's prototype chain.
In summary, instanceof is great for checking class inheritance, {}.toString is useful for getting the type as a string, and Symbol.hasInstance allows you to customize the behavior of instanceof. These tools can be combined to perform powerful and flexible type checks in JavaScript.

Mixins in JavaScript provide a way to add functionality to classes without using inheritance. While JavaScript supports single inheritance, mixins allow you to augment a class with methods from other objects, helping overcome the limitation of only having one superclass. This is particularly useful when you want a class to share functionality from multiple sources.

What is a Mixin?
A mixin is essentially an object containing methods that can be copied into other objects or classes. It provides additional functionality without creating a direct inheritance relationship.

Simple Mixin Example
Here’s a basic example of a mixin in JavaScript:

javascript
Copy code
let sayHiMixin = {
  sayHi() {
    alert(`Hello ${this.name}`);
  },
  sayBye() {
    alert(`Bye ${this.name}`);
  }
};

class User {
  constructor(name) {
    this.name = name;
  }
}

// Copy the methods from sayHiMixin into User prototype
Object.assign(User.prototype, sayHiMixin);

// Now User can use the mixin methods
let user = new User("Dude");
user.sayHi(); // Hello Dude!
In this example, the sayHiMixin object contains methods that we copy into User.prototype using Object.assign(). This allows instances of User to use sayHi() and sayBye() methods even though they were not part of User's original definition.

Inheriting in Mixins
Mixins can also use inheritance inside themselves, allowing for more complex behavior composition. For example:

javascript
Copy code
let sayMixin = {
  say(phrase) {
    alert(phrase);
  }
};

let sayHiMixin = {
  __proto__: sayMixin, // Inherit from sayMixin

  sayHi() {
    super.say(`Hello ${this.name}`); // Call the inherited method
  },
  sayBye() {
    super.say(`Bye ${this.name}`);
  }
};

class User {
  constructor(name) {
    this.name = name;
  }
}

// Copy methods from sayHiMixin into User prototype
Object.assign(User.prototype, sayHiMixin);

// Now User can use inherited methods
let user = new User("Dude");
user.sayHi(); // Hello Dude!
In this case, sayHiMixin inherits from sayMixin, and its methods use super to call the inherited say() method. This is how inheritance can work within a mixin itself.

Event Mixin Example
Mixins are especially useful for adding reusable functionality, such as event handling. Here’s an example of an event mixin:

javascript
Copy code
let eventMixin = {
  on(eventName, handler) {
    if (!this._eventHandlers) this._eventHandlers = {};
    if (!this._eventHandlers[eventName]) {
      this._eventHandlers[eventName] = [];
    }
    this._eventHandlers[eventName].push(handler);
  },

  off(eventName, handler) {
    let handlers = this._eventHandlers?.[eventName];
    if (!handlers) return;
    for (let i = 0; i < handlers.length; i++) {
      if (handlers[i] === handler) {
        handlers.splice(i--, 1);
      }
    }
  },

  trigger(eventName, ...args) {
    if (!this._eventHandlers?.[eventName]) {
      return;
    }
    this._eventHandlers[eventName].forEach(handler => handler.apply(this, args));
  }
};

class Menu {
  choose(value) {
    this.trigger("select", value);
  }
}

// Add the eventMixin functionality to Menu class
Object.assign(Menu.prototype, eventMixin);

let menu = new Menu();

// Add a handler for the "select" event
menu.on("select", value => alert(`Value selected: ${value}`));

// Trigger the "select" event
menu.choose("123"); // Value selected: 123
The eventMixin provides methods for subscribing to (on), unsubscribing from (off), and triggering (trigger) events. This functionality is added to the Menu class via Object.assign().

Advantages of Mixins
Code Reusability: Mixins allow for the reuse of common functionality across multiple classes without inheritance.
Flexibility: You can augment existing classes with new functionality without modifying their inheritance chain.
No Multiple Inheritance: JavaScript doesn’t support multiple inheritance, but mixins allow you to bring functionality from multiple sources.
Separation of Concerns: Mixins help separate concerns by keeping related methods in distinct objects, making your code cleaner and more modular.
Potential Pitfalls
Method Name Collisions: Since mixins copy methods into a class’s prototype, they could accidentally overwrite existing methods. To mitigate this, you should ensure that the method names in the mixins are unique or use a naming convention to avoid conflicts.

For example, a more unique naming scheme could be onEvent_select instead of just on to avoid clashes with existing on methods in the class.

Debugging Complexity: Since mixins combine multiple behaviors into a single class, it can sometimes be harder to trace where a specific method or property came from.

Conclusion
Mixins in JavaScript offer a powerful way to add functionality to classes without using inheritance. By copying methods into a class's prototype, mixins enable flexible composition of behaviors and allow you to avoid the limitations of single inheritance. They are particularly useful when you need to add functionality like event handling, logging, or validation across multiple classes. However, it's important to be mindful of method name conflicts when using them.


Chapter 10 Error handling
 JavaScript using the try...catch mechanism. Here's a summary and breakdown of the key concepts and examples you've explored:

1. Basic Syntax of try...catch:
javascript
Copy code
try {
  // Code that might throw an error
} catch (err) {
  // Handle the error
}
try Block: Code that might generate an error goes here.
catch Block: If an error occurs inside try, the flow moves to catch. The err object contains details of the error.
2. Examples:
Errorless Example: When no errors occur, catch is ignored.
javascript
Copy code
try {
  alert('Start of try');
  alert('End of try');
} catch (err) {
  alert('Catch is ignored');
}
Example with Error: When an error occurs in try, the script jumps to catch.
javascript
Copy code
try {
  lalala; // Throws an error because "lalala" is not defined
} catch (err) {
  alert(`Error has occurred! ${err}`);
}
3. Error Handling with Runtime Errors:
Runtime Errors: Errors that occur during execution (e.g., undefined variables).
Syntax Errors: Errors in the code that prevent it from being parsed by the engine (e.g., unmatched curly braces).
4. Error Object:
When an error occurs, JavaScript creates an error object with:

name: The type of the error (e.g., ReferenceError, SyntaxError).
message: The error's message.
stack: The stack trace (used for debugging).
5. throw Operator:
You can manually throw errors to handle specific cases, using throw:

javascript
Copy code
throw new Error("Something went wrong");
You can use built-in error constructors (e.g., Error, SyntaxError, ReferenceError).
6. Rethrowing Errors:
Sometimes, we catch an error but need to pass it on (rethrow it) for further handling:

javascript
Copy code
try {
  // Some code that might throw an error
} catch (err) {
  if (err instanceof SyntaxError) {
    alert("Handling SyntaxError");
  } else {
    throw err; // Rethrow unexpected errors
  }
}
7. finally Block:
The finally block always runs, whether an error occurs or not:

javascript
Copy code
try {
  // Code that might throw an error
} catch (err) {
  // Error handling
} finally {
  // Always executed, used for cleanup or final steps
}
Use Case: It's helpful for things like timing operations (e.g., logging execution time) that need to run regardless of errors.
8. Global Error Handling:
In Browsers: window.onerror can catch uncaught errors globally.
javascript
Copy code
window.onerror = function(message, url, line, col, error) {
  alert(`Error: ${message} at ${url}:${line}:${col}`);
};
9. Real-World Example (JSON Parsing):
If parsing a JSON string fails, you can use try...catch to handle the error gracefully:

javascript
Copy code
let json = "{ bad json }"; // Malformed JSON

try {
  let user = JSON.parse(json);
} catch (err) {
  alert("Our apologies, the data has errors, we'll try again.");
  alert(err.message); // Shows error details
}
This example shows how to handle invalid data from external sources (like APIs) without the script "dying."
10. try...catch...finally:
Use finally for cleanup tasks that need to run no matter what happens in try or catch.
Example with Execution Time Measurement: Even if an error occurs, we measure the execution time.
javascript
Copy code
let start = Date.now();

try {
  result = fib(num);
} catch (err) {
  result = 0;
} finally {
  let diff = Date.now() - start;
  alert(`Execution took ${diff}ms`);
}
Summary of Key Takeaways:
try...catch handles runtime errors and prevents the script from crashing.
throw is used to create custom errors.
finally ensures that certain code executes no matter the result of try/catch.
Rethrowing errors (throw err) ensures that only known errors are handled while others propagate for further handling.
This error-handling structure is essential in JavaScript, as it provides a robust way to manage unexpected scenarios and prevent your code from failing unexpectedly. Would you like to dive deeper into any of these concepts or explore some more advanced use cases?

Key Concepts:
Extending the Error Class: JavaScript allows us to create custom error classes by extending the built-in Error class. This gives us the ability to define errors specific to our application's needs, such as HttpError, DbError, and NotFoundError.

Error Properties: Custom error classes can inherit the basic properties of Error, such as message, name, and stack. They can also introduce additional properties like statusCode or property to store more specific information about the error.

Custom Error Class Example: The ValidationError class is a good example of how to extend the Error class. This custom error is thrown when data fails validation, and the constructor accepts a message to describe the error.

Instance Checking: When catching errors, the instanceof operator is used to check for specific types of errors, allowing you to handle each error type accordingly. This is especially useful if you have a hierarchy of errors (e.g., PropertyRequiredError extending ValidationError).

Simplifying Custom Errors: A more generic base class like MyError can simplify the creation of custom error classes. It automatically sets the name property to the class name, reducing redundancy.

Wrapping Exceptions: A higher-level error can wrap lower-level errors to provide a more abstract and unified error-handling approach. For example, the ReadError class could wrap both SyntaxError and ValidationError from the readUser function, allowing the calling code to handle them uniformly.

Example Code:
javascript
Copy code
class MyError extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
}

class ValidationError extends MyError { }

class PropertyRequiredError extends ValidationError {
  constructor(property) {
    super("No property: " + property);
    this.property = property;
  }
}

// Usage in function
function readUser(json) {
  let user = JSON.parse(json);
  if (!user.age) {
    throw new PropertyRequiredError("age");
  }
  if (!user.name) {
    throw new PropertyRequiredError("name");
  }
  return user;
}

try {
  let user = readUser('{ "age": 25 }');
} catch (err) {
  if (err instanceof ValidationError) {
    console.error("Invalid data: " + err.message);
  } else if (err instanceof SyntaxError) {
    console.error("JSON Syntax Error: " + err.message);
  } else {
    throw err; // rethrow unknown error
  }
}
Benefits:
Error Hierarchy: Custom errors can be part of a hierarchy, making it easier to organize and handle various error types in a structured way.
Flexibility: You can define errors with additional properties that provide more context (e.g., statusCode, property).
Error Wrapping: Wrapping low-level errors into higher-level errors allows you to handle specific cases without dealing with numerous error types, thus simplifying error handling.
Wrapping Exceptions:
When multiple error types can occur in a function, it's often more convenient to "wrap" those errors into a single, higher-level error that provides the necessary context. This makes it easier to handle errors more abstractly without having to explicitly check for every possible error type.

javascript
Copy code
class ReadError extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = 'ReadError';
  }
}

// Wrapping SyntaxError and ValidationError
function readUser(json) {
  let user;
  try {
    user = JSON.parse(json);
  } catch (err) {
    if (err instanceof SyntaxError) {
      throw new ReadError("Syntax Error", err);
    }
    throw err; // rethrow unexpected error
  }

  try {
    validateUser(user);
  } catch (err) {
    if (err instanceof ValidationError) {
      throw new ReadError("Validation Error", err);
    }
    throw err; // rethrow unexpected error
  }
}
Conclusion:
By extending the Error class, JavaScript allows for more organized and expressive error handling. Custom error classes with specific properties and the use of instanceof for error detection enable better debugging and clearer error management in your applications. Wrapping exceptions adds another layer of abstraction, making it easier to manage multiple error types.

Chapter 11 Promises, async/await

Introduction to Callbacks in JavaScript
In JavaScript, callbacks are functions passed as arguments to other functions, executed after the completion of a task, typically asynchronous operations like loading resources, handling user interactions, or waiting for responses from a server.

Let's explore the example of loadScript, which loads a JavaScript script dynamically into the HTML page. This demonstrates the basic callback mechanism.

Loading a Script Dynamically
Consider the following function to load a script dynamically into the document:

javascript
Copy code
function loadScript(src) {
  let script = document.createElement('script');
  script.src = src;
  document.head.append(script);
}
In this case, we’re adding a <script> element to the page, which tells the browser to load and execute the script asynchronously. This means the rest of the code continues executing immediately, without waiting for the script to load.

For example:

javascript
Copy code
loadScript('/my/script.js');
// The script is loaded in the background, but this code doesn't wait for it to finish.
However, if we want to execute some code once the script has loaded, we need to track its loading completion. This is where callbacks come in.

Adding a Callback for Script Loading
We can modify the loadScript function to accept a callback function that will be called once the script has successfully loaded:

javascript
Copy code
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;
  script.onload = () => callback(script);  // Executes callback after loading
  document.head.append(script);
}
Now, we can provide a callback function when calling loadScript to run something after the script has loaded:

javascript
Copy code
loadScript('/my/script.js', function() {
  console.log("The script has loaded, and I can now use its functions!");
});
Example with External Script
Here’s a more concrete example where we load a script from a CDN and use a function defined in that script once it’s loaded:

javascript
Copy code
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;
  script.onload = () => callback(script);
  document.head.append(script);
}

loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {
  alert(`Cool, the script ${script.src} is loaded`);
  alert(_);  // _ is a function declared in the loaded script
});
Callback in Callback: Loading Scripts Sequentially
What if we need to load multiple scripts one after the other? We can nest the callbacks inside each other:

javascript
Copy code
loadScript('/my/script1.js', function(script) {
  alert("First script loaded, loading second one...");
  loadScript('/my/script2.js', function(script) {
    alert("Second script loaded!");
  });
});
This way, the second script only loads after the first one finishes.

Handling Errors
Asynchronous tasks like loading scripts might fail (for example, the file might not exist). So, we need to handle errors as well. We can extend the loadScript function to track load errors:

javascript
Copy code
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);  // Success callback with `null` error
  script.onerror = () => callback(new Error(`Script load error for ${src}`));  // Error callback

  document.head.append(script);
}
Here’s how you would use it:

javascript
Copy code
loadScript('/my/script.js', function(error, script) {
  if (error) {
    console.error("Error loading the script: ", error);
  } else {
    console.log("Script loaded successfully!");
  }
});
Pyramid of Doom: Callback Hell
When loading many scripts or performing several asynchronous operations sequentially, you may end up with deeply nested callbacks, like this:

javascript
Copy code
loadScript('1.js', function(error, script) {
  if (error) {
    handleError(error);
  } else {
    loadScript('2.js', function(error, script) {
      if (error) {
        handleError(error);
      } else {
        loadScript('3.js', function(error, script) {
          if (error) {
            handleError(error);
          } else {
            // Continue after all scripts are loaded
          }
        });
      }
    });
  }
});
This is often referred to as the Pyramid of Doom because of its deep indentation and the difficulty in reading the code.

Refactoring to Avoid Pyramid of Doom
You can refactor nested callbacks into separate functions to reduce nesting:

javascript
Copy code
loadScript('1.js', step1);

function step1(error, script) {
  if (error) {
    handleError(error);
  } else {
    loadScript('2.js', step2);
  }
}

function step2(error, script) {
  if (error) {
    handleError(error);
  } else {
    loadScript('3.js', step3);
  }
}

function step3(error, script) {
  if (error) {
    handleError(error);
  } else {
    // Continue after all scripts are loaded
  }
}
This reduces nesting but can still be a bit cumbersome and hard to read.

Conclusion
While callbacks are a fundamental part of asynchronous programming in JavaScript, they can lead to deeply nested code that is difficult to maintain (known as "callback hell"). To avoid this, it's often better to use Promises or async/await, which provide cleaner and more manageable ways to handle asynchronous operations.

avaScript Promises, describing their role in asynchronous programming through a real-life analogy. Here's a breakdown of the core concepts:

1. The Analogy of Promises:
Singer (Producing code): The part of your code that does something and takes time, like loading data from the network.
Fans (Consuming code): The code that wants the result once it's ready.
Promise: The "subscription list" that connects the singer (producing code) with the fans (consuming code). It ensures that when the result is ready (or if there’s an error), all subscribers (fans) are notified.
2. The Promise Constructor:
new Promise creates a promise object. It takes an executor function as an argument, which is executed immediately upon the creation of the promise.
The executor has two functions: resolve (when the job is done successfully) and reject (when there's an error).
The promise's state changes as follows:
Pending: Initial state.
Fulfilled: If the job is done successfully.
Rejected: If there’s an error.
3. Executor Behavior:
The executor performs the asynchronous task and calls either resolve(value) if successful, or reject(error) if there's an error.
A promise can only be resolved or rejected once, and any further attempts are ignored.
4. Promise States and Handlers:
Pending: Initial state.
Fulfilled: Once resolved.
Rejected: If there is an error.
then(): The method to handle both success and error outcomes of a promise. It can take two functions, one for a successful result and one for an error.
catch(): A shorthand for handling errors. It’s an alias for .then(null, errorHandlingFunction).
finally(): A method that runs after the promise settles (whether fulfilled or rejected). It’s used for cleanup tasks and doesn’t know the outcome of the promise.
5. Immediate Resolution:
Promises don’t have to resolve asynchronously; they can resolve immediately if the result is ready.
6. Practical Example: loadScript Function:
Callback-based: A traditional approach using a callback to handle the result of an asynchronous operation.
Promise-based: Refactors the loadScript function to return a promise, allowing for easier chaining and cleaner code.
With promises, we can use .then() to handle results and errors and chain multiple handlers to process the result in a more readable and manageable way.
7. Benefits Over Callbacks:
Promises allow for more flexible, readable, and maintainable code.
Multiple handlers can be chained to a promise, whereas callbacks can only be used once.
Promises provide a better way to handle asynchronous tasks, as they manage success, error, and finalization in a cleaner way.
In summary, JavaScript Promises simplify handling asynchronous operations, improve code organization, and offer better handling for both success and failure cases compared to traditional callback methods.
 
 promise chaining in JavaScript. The main focus is on using promises to handle asynchronous operations in a sequence, which is a better alternative to callback-based approaches that can lead to "callback hell" (also known as the "pyramid of doom"). Here's a summary of the key concepts from this chapter:

Promise Chaining
Promise chaining allows you to execute a series of asynchronous operations in a sequence. Each .then() in the chain receives the result of the previous one. For instance:

javascript
Copy code
new Promise(function(resolve) {
  setTimeout(() => resolve(1), 1000);
})
.then(result => {
  console.log(result);  // 1
  return result * 2;
})
.then(result => {
  console.log(result);  // 2
  return result * 2;
})
.then(result => {
  console.log(result);  // 4
});
Here, each .then() takes the result from the previous .then(), processes it, and passes it along the chain. The main point of chaining is that each handler's result is passed to the next handler in sequence, rather than processing each handler independently.

Returning Promises
One of the key features of promises is that a .then() handler can return a new promise. This makes it possible to chain asynchronous operations in a non-blocking way. For example:

javascript
Copy code
new Promise(function(resolve) {
  setTimeout(() => resolve(1), 1000);
})
.then(result => {
  return new Promise(resolve => {
    setTimeout(() => resolve(result * 2), 1000);
  });
})
.then(result => {
  console.log(result);  // 2
});
In this case, the second .then() returns a promise, and the subsequent .then() waits for it to resolve before executing.

Chaining with Asynchronous Tasks (like loadScript)
The chapter demonstrates how to load multiple scripts one after another using promise chaining:

javascript
Copy code
loadScript("/path/to/script1.js")
  .then(() => loadScript("/path/to/script2.js"))
  .then(() => loadScript("/path/to/script3.js"))
  .then(() => {
    // All scripts are loaded, now use the functions
    script1Function();
    script2Function();
    script3Function();
  });
By returning promises from each .then(), the scripts are loaded in sequence, and the following script is loaded only after the previous one is done.

Common Mistakes: Adding Multiple .then() to One Promise
It's important to note that simply adding multiple .then() to a single promise doesn't chain the operations. Instead, each .then() handler will execute independently:

javascript
Copy code
let promise = new Promise(function(resolve) {
  setTimeout(() => resolve(1), 1000);
});

promise.then(result => {
  console.log(result);  // 1
  return result * 2;
});
promise.then(result => {
  console.log(result);  // 1 (not 2)
});
In this case, each .then() receives the same initial result (1), and no chaining happens. The handlers execute independently of one another.

Thenables
A thenable is any object that implements a then method, and it behaves like a promise when used in promise chains. For instance:

javascript
Copy code
class Thenable {
  constructor(num) {
    this.num = num;
  }
  then(resolve, reject) {
    setTimeout(() => resolve(this.num * 2), 1000);
  }
}

new Promise(resolve => resolve(1))
  .then(result => new Thenable(result))
  .then(alert);  // Alerts 2 after 1000ms
Here, Thenable is not a native promise, but it implements the .then() method and can be used like a promise.

Example with Fetch API
The chapter also demonstrates how promises are used in real-world scenarios like network requests, with an example using the fetch API:

javascript
Copy code
fetch('/path/to/data.json')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.log(error));
The fetch function returns a promise, and the .then() method processes the response once it's available.

Handling Multiple Asynchronous Actions
The example with GitHub avatars shows how to chain multiple asynchronous actions, like making multiple requests, and ensuring that actions occur in a specified order:

javascript
Copy code
fetch('/user.json')
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  .then(response => response.json())
  .then(githubUser => {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    document.body.append(img);
    setTimeout(() => img.remove(), 3000);
  });
Best Practices
Always return a promise from an asynchronous operation inside a .then() handler. This ensures that the rest of the chain waits for it to settle before proceeding.
Keep the code "flat" by chaining .then() handlers instead of nesting them. This avoids the "pyramid of doom."
Use reusable functions to keep the code organized and maintainable.
Summary
Promise chaining is a powerful feature in JavaScript for managing sequences of asynchronous tasks. By returning promises from .then() handlers, you can ensure that asynchronous actions are performed in the correct order and avoid common pitfalls like callback hell. It's a great way to handle sequential tasks such as loading scripts, fetching data from an API, and other asynchronous operations.

Basic Error Handling with .catch
In a promise chain, .catch is used to handle errors that occur in any of the previous .then handlers. When a promise is rejected (e.g., a network error, invalid data), the control jumps to the nearest rejection handler, making it easy to catch and handle errors.

For example, if a network request fails, you can catch the error like this:

javascript
Copy code
fetch('https://no-such-server.blabla') // rejects
  .then(response => response.json())
  .catch(err => alert(err)); // TypeError: failed to fetch
Implicit try...catch in Promises
Promise executors (the function you pass to new Promise()) and handlers (the functions passed to .then) have an "invisible" try...catch around them. This means that if an exception occurs, it's automatically caught and treated as a promise rejection.

For example:

javascript
Copy code
new Promise((resolve, reject) => {
  throw new Error("Whoops!");
}).catch(alert); // Error: Whoops!
Handling Errors and Propagating Them
You can rethrow errors inside a .catch handler to propagate them further down the chain. This is similar to rethrowing an error in a traditional try...catch block.

For example:

javascript
Copy code
new Promise((resolve, reject) => {
  throw new Error("Whoops!");
})
  .catch(error => {
    alert("The error is handled, continue normally");
  })
  .then(() => alert("Next successful handler runs"));
If you need to catch an error but still want to propagate it, you can rethrow it:

javascript
Copy code
new Promise((resolve, reject) => {
  throw new Error("Whoops!");
})
  .catch(error => {
    if (error instanceof URIError) {
      // Handle specific error
    } else {
      alert("Can't handle such error");
      throw error; // Rethrow the error to the next .catch
    }
  })
  .catch(error => {
    alert(`The unknown error has occurred: ${error}`);
  });
Unhandled Promise Rejections
When a promise is rejected and no .catch handler is provided, the rejection is "stuck" and unhandled. In modern JavaScript, unhandled promise rejections are tracked, and a global error is triggered.

To catch such unhandled promise rejections in browsers, you can use the unhandledrejection event:

javascript
Copy code
window.addEventListener('unhandledrejection', function(event) {
  alert(event.promise); // The promise that generated the error
  alert(event.reason);  // The error object
});
This ensures that you can respond to unhandled promise rejections and inform the user or log the error to a server.

Summary
.catch handles errors in promise chains, catching both explicit rejections and errors thrown inside handlers.
You can rethrow errors in .catch to propagate them to the next error handler.
Always ensure you handle errors, either with .catch or by using the unhandledrejection event to catch unhandled promise rejections.
Unhandled promise rejections can lead to unresponsive or broken applications, so it's important to track and address them.
By using proper error handling with promises, you can create more stable and predictable asynchronous workflows.

The Promise API in JavaScript offers several useful methods to manage multiple promises in different scenarios. Here's a breakdown of each static method and how they work:

1. Promise.all(iterable)
Use Case: Waits for all promises in an iterable (usually an array) to resolve. Returns an array with the results of each promise.
Important: If any promise rejects, the entire Promise.all rejects, and the error will be passed to .catch.
Example:

javascript
Copy code
Promise.all([
  new Promise(resolve => setTimeout(() => resolve(1), 1000)),
  new Promise(resolve => setTimeout(() => resolve(2), 2000)),
  new Promise(resolve => setTimeout(() => resolve(3), 3000))
]).then(results => console.log(results)); // Output: [1, 2, 3]
If any of the promises rejects:

javascript
Copy code
Promise.all([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Whoops!")), 2000))
]).catch(error => console.log(error.message)); // Output: "Whoops!"
2. Promise.allSettled(iterable)
Use Case: Waits for all promises to settle, regardless of whether they resolve or reject. Returns an array of objects containing the status ("fulfilled" or "rejected") and either value or reason.
Important: This is helpful when you want to know the outcome of all promises, even if some fail.
Example:

javascript
Copy code
Promise.allSettled([
  Promise.resolve(1),
  Promise.reject("Error 2"),
  Promise.resolve(3)
]).then(results => console.log(results));
// Output: 
// [{ status: 'fulfilled', value: 1 }, { status: 'rejected', reason: 'Error 2' }, { status: 'fulfilled', value: 3 }]
3. Promise.race(iterable)
Use Case: Waits for the first promise to settle (either resolve or reject). The result of the first settled promise is returned, and all other promises are ignored.
Important: Useful when you want to act as soon as any promise completes, regardless of success or failure.
Example:

javascript
Copy code
Promise.race([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Whoops!")), 500))
]).then(result => console.log(result)) // Output: Error: Whoops!
  .catch(error => console.log(error.message)); // Output: Whoops!
4. Promise.any(iterable)
Use Case: Similar to Promise.race, but it only returns the first promise that fulfills (i.e., resolves). If all promises are rejected, it returns an AggregateError containing all the rejection reasons.
Important: This is useful when you want to proceed with the first successful result, but still want to know if all promises fail.
Example:

javascript
Copy code
Promise.any([
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Whoops!")), 1000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 2000))
]).then(result => console.log(result)); // Output: 1
Example with rejection:

javascript
Copy code
Promise.any([
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ouch!")), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Error!")), 2000))
]).catch(error => {
  console.log(error.constructor.name); // Output: AggregateError
  console.log(error.errors[0]); // Output: Error: Ouch!
  console.log(error.errors[1]); // Output: Error: Error!
});
5. Promise.resolve(value)
Use Case: Creates a resolved promise with the given value. This is often used when you want to ensure that a function always returns a promise, even if it's already resolved.
Example:

javascript
Copy code
Promise.resolve(42).then(result => console.log(result)); // Output: 42
6. Promise.reject(reason)
Use Case: Creates a rejected promise with the given reason (usually an error).
Important: This is less commonly used, but it's helpful when you want to immediately reject a promise.
Example:

javascript
Copy code
Promise.reject(new Error("Something went wrong")).catch(error => console.log(error.message)); // Output: Something went wrong
Summary:
Promise.all is great for waiting for multiple promises to resolve successfully.
Promise.allSettled waits for all promises to settle, regardless of whether they succeed or fail.
Promise.race is useful when you need the first promise that settles (either resolves or rejects).
Promise.any gives the result of the first fulfilled promise or an AggregateError if all are rejected.
Promise.resolve and Promise.reject create promises that are already resolved or rejected, respectively.
These static methods provide powerful tools for handling multiple asynchronous operations in parallel and ensure better control over your asynchronous workflows.

Promisification is a powerful technique for transforming traditional callback-based functions into promise-based ones. This makes it easier to work with asynchronous code, especially when using newer features like async/await. Let's break down the concept and steps:

1. The Original Callback-based Function
In many JavaScript APIs, especially older ones, asynchronous functions follow a common pattern where they accept a callback function as the last argument. This callback is called when the operation is complete, and the result (or error) is passed to it.

For example:

javascript
Copy code
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);  // Success
  script.onerror = () => callback(new Error(`Script load error for ${src}`));  // Error

  document.head.append(script);
}
2. Converting a Callback-based Function to a Promise
To make it easier to use in modern JavaScript, we can transform this function into one that returns a promise. Here's how you can do it:

javascript
Copy code
let loadScriptPromise = function(src) {
  return new Promise((resolve, reject) => {
    loadScript(src, (err, script) => {
      if (err) reject(err); // Reject the promise if there's an error
      else resolve(script); // Resolve with the script if successful
    });
  });
};

// Usage:
loadScriptPromise('path/script.js').then(script => {
  console.log('Script loaded:', script);
}).catch(err => {
  console.error('Failed to load script:', err);
});
In this case, loadScriptPromise wraps loadScript and turns it into a function that returns a promise. When the original function calls the callback, the promise is either resolved or rejected based on the callback's parameters.

3. Creating a General Promisification Helper
If you need to promisify many callback-based functions, you can create a helper function that wraps any such function. Here's a generic promisify function:

javascript
Copy code
function promisify(f) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      function callback(err, result) {
        if (err) reject(err);
        else resolve(result);
      }

      args.push(callback); // Add the callback as the last argument
      f.call(this, ...args); // Call the original function
    });
  };
}

// Usage:
let loadScriptPromise = promisify(loadScript);
loadScriptPromise('path/script.js').then(script => {
  console.log('Script loaded:', script);
}).catch(err => {
  console.error('Failed to load script:', err);
});
This function works by adding a custom callback to the list of arguments and using that callback to resolve or reject the promise.

4. Handling Multiple Callback Results
Some functions may pass multiple results to the callback. If the original function returns more than one value (e.g., callback(err, result1, result2, ...)), you can modify the promisify helper to return all results in an array or just the first result:

javascript
Copy code
function promisify(f, manyArgs = false) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      function callback(err, ...results) {
        if (err) {
          reject(err);
        } else {
          resolve(manyArgs ? results : results[0]);
        }
      }

      args.push(callback); // Add the callback to the arguments
      f.call(this, ...args); // Call the original function
    });
  };
}

// Usage:
let multiResultFunc = promisify(someFunction, true);
multiResultFunc(...).then(results => {
  console.log(results); // All results in an array
}).catch(err => {
  console.error('Error:', err);
});
Here, manyArgs determines whether all results are returned as an array or just the first one.

5. Custom Promisification for Non-standard Callbacks
In cases where the callback doesn't follow the usual (err, result) pattern (e.g., no error argument), you may need to handle it manually.

For instance, for callbacks like callback(result) (i.e., the callback only takes one argument), you could create a custom promisification like this:

javascript
Copy code
function promisifyOneArg(f) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      function callback(result) {
        resolve(result);
      }

      args.push(callback);
      f.call(this, ...args);
    });
  };
}
This would work for functions where the callback doesn't need to handle errors and simply resolves with the result.

6. Why Use Promisification?
Cleaner Code: Promisified functions integrate seamlessly with async/await syntax, which makes the code more readable and easier to reason about compared to traditional callback-based approaches.
Error Handling: Promises provide a unified way to handle errors with .catch() or try/catch in async functions, which is more elegant than handling errors in each callback.
Chainability: Promises allow chaining .then() and .catch() calls, which simplifies composing multiple asynchronous operations.
7. Limitations of Promisification
One-time Callbacks: Promisification is designed for functions that call the callback once. If the callback is called multiple times (e.g., event listeners or streams), promisification won't be ideal, and you would need to consider other strategies.
Node.js & Utility Libraries: In Node.js, there's a built-in util.promisify function for promisifying callback-style APIs. Libraries like bluebird also provide flexible promisification tools that can handle more complex cases.
Promisification helps modernize asynchronous code, making it easier to work with and understand, especially in larger applications.


Microtasks in JavaScript are a critical concept in the execution order of asynchronous code. Understanding how promise handlers like .then(), .catch(), and .finally() interact with the microtask queue helps us explain why some code appears to execute out of order, even when promises are resolved immediately.

What Are Microtasks?
Microtasks are tasks that are scheduled to run after the currently executing script and before any other events in the event loop (such as I/O events, timers, etc.). When a promise is resolved or rejected, its .then(), .catch(), or .finally() handlers are added to the microtask queue, which means that these handlers will not run immediately after a promise is resolved but after the current script finishes executing and before any other macrotasks (like UI rendering or event handlers).

Key Concepts:
Promise Handlers Are Asynchronous: Even if a promise is already resolved, handlers attached via .then(), .catch(), or .finally() will always be executed asynchronously, in the microtask queue.

Microtask Queue: This queue holds promise handlers and other tasks like MutationObserver callbacks, and they are executed in the order they are added. They are processed after the current script finishes but before any other tasks in the event loop (macrotasks).

Example 1: Understanding Microtasks
Here’s an example that demonstrates the behavior of promise handlers in the microtask queue:

javascript
Copy code
let promise = Promise.resolve();

promise.then(() => alert("promise done!"));

alert("code finished");  // This alert shows first
Output:

code finished
promise done!
Why?

The Promise.resolve() resolves immediately, but its .then() handler is scheduled to run in the microtask queue.
JavaScript executes the code synchronously (alerting "code finished" first) before checking the microtask queue.
After the current script finishes, the microtask queue is processed, and the "promise done!" alert is triggered.
Example 2: Controlling Order of Execution
To control the order of execution, we can chain .then() calls to ensure that subsequent code runs after promise handlers:

javascript
Copy code
Promise.resolve()
  .then(() => alert("promise done!"))
  .then(() => alert("code finished"));
Output:

promise done!
code finished
Why?

The promise is resolved immediately, but the second .then() ensures that "code finished" only runs after "promise done!" is triggered.
Example 3: Handling Unhandled Rejections
JavaScript also provides a way to handle unhandled promise rejections, which can occur when a promise is rejected but no .catch() handler is attached. The unhandledrejection event is triggered if a rejection occurs and is not handled in the microtask queue.

javascript
Copy code
let promise = Promise.reject(new Error("Promise Failed!"));
promise.catch(err => alert('caught'));  // Catches the error

window.addEventListener('unhandledrejection', event => alert(event.reason));
If a rejection is not handled immediately with .catch(), the unhandledrejection event fires after the promise has been rejected and the microtask queue is processed.
If you add a handler later (e.g., via setTimeout), the rejection has already been processed, and the event triggers before the handler is executed.
Example 4: Handling Rejections Later
javascript
Copy code
let promise = Promise.reject(new Error("Promise Failed!"));

setTimeout(() => promise.catch(err => alert('caught')), 1000);

// This triggers first:
window.addEventListener('unhandledrejection', event => alert(event.reason));
Output:

"Promise Failed!" (from unhandledrejection)
"caught" (from the setTimeout handler)
Why?

The unhandled rejection event triggers because no .catch() was attached immediately.
When the setTimeout runs, the rejection is already processed, and the event had already been fired, so it doesn't change anything.
Key Takeaways:
Microtasks ensure that promise handlers always run after the current code and before other tasks like events or timers.
Promise handlers are always asynchronous, even if the promise is already resolved or rejected.
If you need to guarantee that certain code runs after a promise handler, you should chain .then() calls.
The concept of unhandled rejections is tied to the microtask queue and will be triggered if a promise rejection isn't caught by a .catch() by the time the microtask queue is cleared.
This helps ensure that asynchronous operations (like promises) are managed properly in the event loop and are executed in the correct order.

The async/await syntax in JavaScript is designed to make working with asynchronous code easier and more readable. It provides a way to write asynchronous code that looks and behaves like synchronous code, allowing for cleaner logic and better error handling. Here’s a breakdown of how async/await works:

async Functions
When you prefix a function with the async keyword, it means that the function always returns a promise. If the function returns a non-promise value, it automatically wraps it in a resolved promise.

Example:

javascript
Copy code
async function f() {
  return 1;
}

f().then(alert); // 1
Even if we return a non-promise, it gets wrapped in a resolved promise automatically:

javascript
Copy code
async function f() {
  return Promise.resolve(1);
}

f().then(alert); // 1
await Expression
The await keyword can only be used inside an async function. It pauses the execution of the function until the promise it’s waiting on is resolved or rejected. Once the promise is settled, it returns the result (or throws an error if the promise is rejected).

Example with await:

javascript
Copy code
async function f() {
  let promise = new Promise((resolve) => {
    setTimeout(() => resolve("done!"), 1000);
  });

  let result = await promise; // wait for promise to resolve
  alert(result); // "done!"
}

f();
The function execution pauses at await, and resumes once the promise is resolved.
It doesn’t block the thread (i.e., other tasks can run in the meantime), making it very efficient.
Key Points about await:
It waits for the promise to resolve and retrieves the result.
If the promise is rejected, it throws an error, which we can catch using try...catch.
Error Handling with async/await
You can handle errors in async functions using try...catch, which is much more intuitive compared to chaining .catch with promises.

Example:

javascript
Copy code
async function f() {
  try {
    let response = await fetch('http://no-such-url');
    let user = await response.json();
  } catch (err) {
    alert(err); // handles fetch and JSON parsing errors
  }
}

f();
The error will be caught if any part of the promise chain is rejected.
If you forget the try...catch block, the promise will be rejected and you can handle it with .catch:
javascript
Copy code
f().catch(alert); // catches unhandled errors from f()
Using async/await with Promise.all
async/await works great with Promise.all when you need to handle multiple promises concurrently. You can await the result of all promises once they are all resolved.

Example:

javascript
Copy code
async function fetchData() {
  let [response1, response2] = await Promise.all([
    fetch('url1'),
    fetch('url2')
  ]);

  let data1 = await response1.json();
  let data2 = await response2.json();

  console.log(data1, data2);
}

fetchData();
Using Top-Level await
In modern browsers, you can use await at the top level inside a module. If you are using a script (not a module), await can only be used inside an async function.

Top-level await example:

javascript
Copy code
// Inside a module
let response = await fetch('/some-url');
let data = await response.json();
console.log(data);
For non-modules or older browsers, you can wrap the code in an anonymous async function:

javascript
Copy code
(async () => {
  let response = await fetch('/some-url');
  let data = await response.json();
  console.log(data);
})();
await and "Thenables"
await can work with objects that are "thenable", meaning they have a .then() method, even if they are not actual Promise objects.

Example:

javascript
Copy code
class Thenable {
  constructor(value) {
    this.value = value;
  }
  then(resolve) {
    setTimeout(() => resolve(this.value * 2), 1000);
  }
}

async function example() {
  let result = await new Thenable(5);
  alert(result); // 10 (after 1 second)
}

example();
async Methods in Classes
You can also use async methods in JavaScript classes. They work just like regular async functions, but you must use await inside them.

Example:

javascript
Copy code
class Waiter {
  async wait() {
    return await Promise.resolve("done");
  }
}

new Waiter()
  .wait()
  .then(alert); // "done"
Summary
async makes a function always return a promise and allows using await inside.
await pauses the function execution until the promise is resolved or rejected.
Error handling can be done with try...catch.
async/await simplifies working with promises, makes code cleaner, and easier to read.
Works seamlessly with Promise.all for handling multiple promises concurrently.
This makes async/await a powerful tool for asynchronous programming in JavaScript, especially for simplifying complex asynchronous logic.


























